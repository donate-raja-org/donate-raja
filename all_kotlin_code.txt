package com.donateraja.annotation
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.EnableAspectJAutoProxy
@Configuration
@EnableAspectJAutoProxy
class AopConfig
import com.donateraja.common.exception.ServiceError
import io.swagger.v3.oas.annotations.Operation
import io.swagger.v3.oas.annotations.media.Content
import io.swagger.v3.oas.annotations.media.ExampleObject
import io.swagger.v3.oas.annotations.media.Schema
import io.swagger.v3.oas.annotations.responses.ApiResponse
import io.swagger.v3.oas.annotations.responses.ApiResponses
import org.springframework.core.annotation.AliasFor
import kotlin.reflect.KClass

@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
@Operation
@ApiResponses(
    value = [
        ApiResponse(
            responseCode = "200",
            description = "Success",
            content = [
                Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = Any::class),
                    examples = [
                        ExampleObject(
                            value = """{"message": "Operation successful", "data": {"userId": 123}}"""
                        )
                    ]
                )
            ]
        ),
        ApiResponse(
            responseCode = "201",
            description = "Created",
            content = [
                Content(
                    mediaType = "application/json",
                    schema = Schema(implementation = Any::class),
                    examples = [ExampleObject(value = """{"message": "User created successfully", "userId": 123}""")]
                )
            ]
        ),
        ApiResponse(
            responseCode = "400",
            description = "Bad request",
            content = [Content(mediaType = "application/json", schema = Schema(implementation = ServiceError::class))]
        ),
        ApiResponse(
            responseCode = "401",
            description = "Unauthorized",
            content = [Content(mediaType = "application/json", schema = Schema(implementation = ServiceError::class))]
        ),
        ApiResponse(
            responseCode = "403",
            description = "Forbidden",
            content = [Content(mediaType = "application/json", schema = Schema(implementation = ServiceError::class))]
        ),
        ApiResponse(
            responseCode = "415",
            description = "Unsupported Media Type",
            content = [Content(mediaType = "application/json", schema = Schema(implementation = ServiceError::class))]
        ),
        ApiResponse(
            responseCode = "500",
            description = "Internal Server Error",
            content = [Content(mediaType = "application/json", schema = Schema(implementation = ServiceError::class))]
        )
    ]
)
annotation class ApiOperationWithCustomResponses(
    @get:AliasFor(annotation = Operation::class, attribute = "summary")
    val summary: String,

    @get:AliasFor(annotation = Operation::class, attribute = "description")
    val description: String,

    val successSchema: KClass<out Any> = Any::class,
    val responseExamples: Array<ExampleObject> = arrayOf()
)
package com.donateraja.annotation
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class PublicAccess
package com.donateraja.annotation
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class RequireAdmin
package com.donateraja.annotation
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class RequireUser
package com.donateraja.annotation
@Target(AnnotationTarget.FUNCTION)
@Retention(AnnotationRetention.RUNTIME)
annotation class RequireUserOrAdmin
package com.donateraja

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication

@SpringBootApplication
class DonaterajaApplication

fun main(args: Array<String>) {
//    println("hashedPassword::${BCryptPasswordEncoder().encode("Admin@123")}")
//
//    // Generate a 256-bit secret key for HMACSHA256
//    val keyGenerator: KeyGenerator = KeyGenerator.getInstance("HmacSHA256")
//    keyGenerator.init(256) // 256-bit key
//    val secretKey: SecretKey = keyGenerator.generateKey()
//    val base64Secret: String = Base64.getEncoder().encodeToString(secretKey.encoded)
//    println("Generated Base64 Secret: $base64Secret") // Print the Base64 encoded secret

    runApplication<DonaterajaApplication>(*args)
}
package com.donateraja.aspect

import jakarta.servlet.http.HttpServletRequest
import org.aspectj.lang.annotation.Aspect
import org.aspectj.lang.annotation.Before
import org.slf4j.LoggerFactory
import org.springframework.security.access.AccessDeniedException
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.stereotype.Component

@Aspect
@Component
class RoleSecurityAspect(private val request: HttpServletRequest) {

    private val logger = LoggerFactory.getLogger(RoleSecurityAspect::class.java)

    /**
     * Allows public access to methods or classes annotated with @PublicAccess.
     */
    @Before("@within(com.donateraja.annotation.PublicAccess) || @annotation(com.donateraja.annotation.PublicAccess)")
    fun allowPublicAccess() {
        // No security check needed for public endpoints
    }

    /**
     * Ensures that the request is authenticated as a regular user.
     */
    @Before("@within(com.donateraja.annotation.RequireUser) || @annotation(com.donateraja.annotation.RequireUser)")
    fun checkUserAccess() {
        val authentication = SecurityContextHolder.getContext().authentication
        if (authentication == null || !authentication.isAuthenticated || authentication.principal !is UserDetails) {
            logger.warn("Unauthorized user access attempt from IP: ${request.remoteAddr}")
            throw AccessDeniedException("Unauthorized: User login required")
        }
    }

    /**
     * Ensures that the request is authenticated as an admin user.
     */
    @Before("@within(com.donateraja.annotation.RequireAdmin) || @annotation(com.donateraja.annotation.RequireAdmin)")
    fun checkAdminAccess() {
        val authentication = SecurityContextHolder.getContext().authentication
        if (authentication == null || !authentication.isAuthenticated || authentication.principal !is UserDetails) {
            logger.warn("Unauthorized admin access attempt from IP: ${request.remoteAddr}")
            throw AccessDeniedException("Unauthorized: Admin login required")
        }

        val authorities = authentication.authorities.map { it.authority }
        if (!authorities.contains("ADMIN")) {
            logger.warn("Forbidden access attempt by user: ${authentication.name} from IP: ${request.remoteAddr}")
            throw AccessDeniedException("Forbidden: Admin role required")
        }
    }

    /**
     * Ensures that the request is authenticated as either a regular user or an admin.
     */
    @Before("@within(com.donateraja.annotation.RequireUserOrAdmin) || @annotation(com.donateraja.annotation.RequireUserOrAdmin)")
    fun checkUserOrAdminAccess() {
        val authentication = SecurityContextHolder.getContext().authentication
        if (authentication == null || !authentication.isAuthenticated || authentication.principal !is UserDetails) {
            logger.warn("Unauthorized user/admin access attempt from IP: ${request.remoteAddr}")
            throw AccessDeniedException("Unauthorized: User or Admin login required")
        }

        val authorities = authentication.authorities.map { it.authority }
        if (!authorities.contains("USER") && !authorities.contains("ADMIN")) {
            logger.warn("Forbidden access attempt by user: ${authentication.name} from IP: ${request.remoteAddr}")
            throw AccessDeniedException("Forbidden: Access requires User or Admin role")
        }
    }
}
package com.donateraja.common

enum class ApplicationConstants(val text: String) {
    TRANSACTION_ID("transaction.id"),
    USER_ID("user.id"),
    REQUEST_URL("url.full"),
    REQUEST_METHOD("http.request.method"),
    REQUEST_DURATION("event.duration"),
    RESPONSE_STATUS_CODE("http.response.status_code");

    companion object {
        // Helper method to fetch enum by key
        fun fromKey(key: String): ApplicationConstants? = values().find { it.text == key }
    }
}
package com.donateraja.common

import com.backblaze.b2.client.B2StorageClient
import com.backblaze.b2.client.B2StorageClientFactory
import com.backblaze.b2.client.contentSources.B2ByteArrayContentSource
import com.backblaze.b2.client.contentSources.B2ContentTypes
import com.backblaze.b2.client.contentSources.B2FileContentSource
import com.backblaze.b2.client.exceptions.B2Exception
import com.backblaze.b2.client.structures.B2UploadFileRequest
import com.donateraja.configuration.BackblazeConfig
import org.springframework.stereotype.Component
import java.io.File
import java.security.MessageDigest

@Component
class BackblazeUtil(private val backblazeConfig: BackblazeConfig) {

    private val b2Client: B2StorageClient by lazy {
        B2StorageClientFactory.createDefaultFactory().create(
            backblazeConfig.applicationKeyId,
            backblazeConfig.applicationKey,
            "donate-raja"
        )
    }

    fun uploadFile(fileBytes: ByteArray, fileName: String, contentType: String = B2ContentTypes.B2_AUTO): String {
        val sha1 = calculateSha1(fileBytes)
        val contentSource = B2ByteArrayContentSource.builder(fileBytes).setSha1OrNull(sha1)
            .build()
        val request = B2UploadFileRequest.builder(backblazeConfig.bucketId, fileName, contentType, contentSource)
            .build()
        b2Client.uploadSmallFile(request)
        return generatePublicUrl(fileName)
    }

    private fun calculateSha1(bytes: ByteArray): String = MessageDigest.getInstance("SHA-1")
        .digest(bytes)
        .joinToString("") { "%02x".format(it) }

    fun uploadFile(filePath: String, fileName: String): String {
        try {
            val file = File(filePath)
            val contentSource = B2FileContentSource.build(file)
            val uploadRequest = B2UploadFileRequest
                .builder(backblazeConfig.bucketId, fileName, B2ContentTypes.B2_AUTO, contentSource)
                .build()

            b2Client.uploadSmallFile(uploadRequest)
            return generatePublicUrl(fileName)
        } catch (e: B2Exception) {
            throw RuntimeException("Failed to upload file: ${e.message}", e)
        }
    }

    fun uploadFiles(filePaths: List<String>, fileNames: List<String>): List<String> {
        if (filePaths.size != fileNames.size) {
            throw IllegalArgumentException("File paths and file names must have the same size.")
        }

        val uploadedUrls = mutableListOf<String>()
        try {
            for (i in filePaths.indices) {
                val filePath = filePaths[i]
                val fileName = fileNames[i]
                val publicUrl = uploadFile(filePath, fileName)
                uploadedUrls.add(publicUrl)
                println("Successfully uploaded file: $fileName")
            }
        } catch (e: B2Exception) {
            throw RuntimeException("Failed to upload files: ${e.message}", e)
        }

        return uploadedUrls
    }

    fun generatePublicUrl(fileName: String): String = "${backblazeConfig.publicBaseUrl}/$fileName"

    fun deleteFile(fileName: String) {
        try {
            val fileVersion = b2Client.getFileInfoByName(backblazeConfig.bucketId, fileName)
            b2Client.deleteFileVersion(fileVersion.fileName, fileVersion.fileId)
        } catch (e: B2Exception) {
            throw RuntimeException("Failed to delete file: ${e.message}", e)
        }
    }

    fun deleteFiles(fileNames: List<String>) {
        try {
            fileNames.forEach { fileName ->
                val fileVersion = b2Client.getFileInfoByName(backblazeConfig.bucketId, fileName)
                b2Client.deleteFileVersion(fileVersion.fileName, fileVersion.fileId)
                println("Successfully deleted file: $fileName")
            }
        } catch (e: B2Exception) {
            throw RuntimeException("Failed to delete files: ${e.message}", e)
        }
    }
}
package com.donateraja.common.exception

import com.fasterxml.jackson.annotation.JsonFormat
import com.fasterxml.jackson.annotation.JsonProperty
import com.fasterxml.jackson.databind.ObjectMapper
import io.swagger.v3.oas.annotations.media.Schema
import java.time.Instant

class ServiceError {

    @JsonProperty("error_code")
    var errorCode: Int? = null

    @Schema(example = "Error message")
    var message: String? = null

    @Schema(example = "Error description")
    var description: String? = null

    @Schema(example = "transaction id to identify the request")
    @JsonProperty("transaction_id")
    var transactionId: String? = null

    @JsonProperty("timestamp")
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd'T'HH:mm:ss.SSS'Z'", timezone = "UTC")
    var timestamp: Instant = Instant.now()

    constructor(
        errorCode: Int?,
        message: String?,
        description: String?,
        transactionId: String?
    ) {
        this.errorCode = errorCode
        this.message = message
        this.description = description
        this.transactionId = transactionId
        this.timestamp = Instant.now()
    }

    override fun toString(): String {
        val jackson = ObjectMapper().findAndRegisterModules()
        return jackson.writerWithDefaultPrettyPrinter().writeValueAsString(this)
    }
}
package com.donateraja.common.exception

import com.donateraja.common.ApplicationConstants
import org.slf4j.MDC
import org.springframework.http.HttpStatus

class ServiceException(val httpStatus: HttpStatus, description: String?) : Exception(httpStatus.name) {
    val error: ServiceError = ServiceError(
        httpStatus.value(),
        httpStatus.name,
        description,
        MDC.get(ApplicationConstants.TRANSACTION_ID.text)
    )
}
package com.donateraja.common.exception

import jakarta.validation.ConstraintViolation
import jakarta.validation.ConstraintViolationException
import mu.KotlinLogging
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.http.converter.HttpMessageNotReadableException
import org.springframework.validation.ObjectError
import org.springframework.web.HttpMediaTypeNotSupportedException
import org.springframework.web.HttpRequestMethodNotSupportedException
import org.springframework.web.bind.MethodArgumentNotValidException
import org.springframework.web.bind.MissingRequestHeaderException
import org.springframework.web.bind.annotation.ControllerAdvice
import org.springframework.web.bind.annotation.ExceptionHandler
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException
import java.util.Objects
import java.util.function.Consumer

@ControllerAdvice
class ServiceExceptionHandler {

    private val logger = KotlinLogging.logger {}

    // Handle ServiceException (custom exception)
    @ExceptionHandler(value = [ServiceException::class])
    fun handleServiceException(serviceException: ServiceException): ResponseEntity<Any> {
        logger.error(serviceException.error.toString())
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [Exception::class])
    fun handleException(exception: Exception): ResponseEntity<Any> {
        logger.error(exception.message)
        if (Objects.nonNull(exception.stackTrace)) {
            for (element in exception.stackTrace) {
                if (Objects.nonNull(element)) {
                    logger.error(element.toString())
                }
            }
        }
        val serviceException = ServiceException(HttpStatus.INTERNAL_SERVER_ERROR, exception.message)
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [HttpMediaTypeNotSupportedException::class])
    fun handleHttpMediaTypeNotSupportedException(exception: HttpMediaTypeNotSupportedException): ResponseEntity<Any> {
        logger.error(exception.message)
        val serviceException = ServiceException(HttpStatus.BAD_REQUEST, exception.message)
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [HttpRequestMethodNotSupportedException::class])
    fun handleHttpRequestMethodNotSupportedException(exception: HttpRequestMethodNotSupportedException): ResponseEntity<Any> {
        logger.error(exception.message)
        val serviceException = ServiceException(HttpStatus.BAD_REQUEST, exception.message)
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [ConstraintViolationException::class])
    fun handleConstraintViolationException(exception: ConstraintViolationException): ResponseEntity<Any> {
        logger.error("Constraint violation: ${exception.message}")
        val fieldErrors: MutableList<String> = ArrayList()
        exception.constraintViolations.forEach(
            Consumer { error: ConstraintViolation<*> ->
                fieldErrors.add(error.message)
            }
        )
        val serviceException = ServiceException(HttpStatus.BAD_REQUEST, exception.message)
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [MethodArgumentTypeMismatchException::class])
    fun handleMethodArgumentTypeMismatchException(exception: MethodArgumentTypeMismatchException): ResponseEntity<Any> {
        logger.error("Argument type mismatch: ${exception.message}")
        val serviceException = ServiceException(HttpStatus.BAD_REQUEST, exception.message)
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [MethodArgumentNotValidException::class])
    fun handleMethodArgumentNotValidException(exception: MethodArgumentNotValidException): ResponseEntity<Any> {
        val fieldErrors: MutableList<String?> = ArrayList()
        exception.bindingResult.allErrors.forEach(Consumer { error: ObjectError -> fieldErrors.add(error.defaultMessage) })
        logger.error(exception.message)
        val serviceException = ServiceException(HttpStatus.BAD_REQUEST, fieldErrors.toString())
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [HttpMessageNotReadableException::class])
    fun handleHttpMessageNotReadableException(exception: HttpMessageNotReadableException): ResponseEntity<Any> {
        logger.error(exception.message)
        val serviceException = ServiceException(HttpStatus.BAD_REQUEST, exception.message)
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [MissingRequestHeaderException::class])
    fun handleMissingRequestHeaderException(exception: MissingRequestHeaderException): ResponseEntity<Any> {
        logger.error(exception.message)
        val serviceException = ServiceException(HttpStatus.FORBIDDEN, exception.message)
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }

    @ExceptionHandler(value = [AccessDeniedException::class])
    fun handleAccessDeniedException(exception: AccessDeniedException): ResponseEntity<Any> {
        logger.error("Access Denied: ${exception.message}")
        val serviceException = ServiceException(HttpStatus.FORBIDDEN, exception.message)
        return ResponseEntity(serviceException.error, serviceException.httpStatus)
    }
}
package com.donateraja.common.filter

import com.donateraja.common.util.JwtUtil
import jakarta.servlet.FilterChain
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.slf4j.LoggerFactory
import org.slf4j.MDC
import org.springframework.core.annotation.Order
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter
import java.util.UUID

@Order(10)
@Component
class CommonRequestFilter(private val jwtUtil: JwtUtil) : OncePerRequestFilter() {

    companion object {
        private const val TRANSACTION_ID = "transaction_id"
        private const val USER_ID = "user_id"
        private const val AUTH_PATH_PREFIX = "/auth/"
    }

    private val logger = LoggerFactory.getLogger(CommonRequestFilter::class.java)

    override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, filterChain: FilterChain) {
        val requestUri = request.requestURI
        // Generate unique transaction ID
        val transactionId = UUID.randomUUID().toString()
        // Extract userId from JWT or set as anonymous
        val userId = extractUserIdFromRequest(request)
        MDC.put(TRANSACTION_ID, transactionId)
        MDC.put(USER_ID, userId)
        // Exclude authentication and Swagger-related requests from logging
        if (requestUri.startsWith(AUTH_PATH_PREFIX) ||
            requestUri.startsWith("/swagger") ||
            requestUri.startsWith("/v3/api-docs") ||
            requestUri.startsWith("/webjars/swagger-ui") ||
            requestUri.startsWith("/swagger-resources")
        ) {
            filterChain.doFilter(request, response)
            return
        }

        val requestStartTime = System.currentTimeMillis()
        var statusCode: Int? = null

        try {
            filterChain.doFilter(request, response)
            statusCode = response.status
        } catch (ex: Exception) {
            statusCode = HttpServletResponse.SC_INTERNAL_SERVER_ERROR
            throw ex
        } finally {
            val requestDuration = System.currentTimeMillis() - requestStartTime
            logRequestDetails(request, statusCode, requestDuration)
            MDC.clear()
        }
    }

    private fun extractUserIdFromRequest(request: HttpServletRequest): String {
        // Check for Bearer token in Authorization header
        val authHeader = request.getHeader("Authorization")
        return if (authHeader != null && authHeader.startsWith("Bearer ")) {
            val token = authHeader.substring(7)
            try {
                jwtUtil.extractUsername(token)
            } catch (e: Exception) {
                "anonymous"
            }
        } else {
            "anonymous"
        }
    }

    private fun logRequestDetails(request: HttpServletRequest, statusCode: Int?, duration: Long) {
        val method = request.method
        val uri = request.requestURI
        val query = request.queryString?.let { "?$it" } ?: ""
        val fullUrl = "$uri$query"

        logger.info(
            "Request Details: Method: $method, URL: $fullUrl, Status: ${statusCode ?: "UNKNOWN"}, " +
                "Duration: ${duration}ms, Transaction ID: ${MDC.get(TRANSACTION_ID)}, " +
                "User ID: ${MDC.get(USER_ID)}"
        )
    }
}
package com.donateraja.common.filter

import com.donateraja.common.util.JwtUtil
import com.donateraja.common.util.UserLookupUtil
import jakarta.servlet.FilterChain
import jakarta.servlet.ServletException
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpServletResponse
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.core.context.SecurityContextHolder
import org.springframework.stereotype.Component
import org.springframework.web.filter.OncePerRequestFilter

@Component
class JwtAuthenticationFilter(private val jwtUtil: JwtUtil, private val userDetailsService: UserLookupUtil) :
    OncePerRequestFilter() {

    @Throws(ServletException::class, java.io.IOException::class)
    override fun doFilterInternal(request: HttpServletRequest, response: HttpServletResponse, chain: FilterChain) {
        val authHeader = request.getHeader("Authorization")

        if (!authHeader.isNullOrEmpty() && authHeader.startsWith("Bearer ")) {
            val token = authHeader.substring(7)

            try {
                if (jwtUtil.isTokenExpired(token)) {
                    response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Token has expired")
                    return
                }

                val email = jwtUtil.extractUsername(token) // Extract email from token
                val claims = jwtUtil.extractAllClaims(token)

                if (SecurityContextHolder.getContext().authentication == null) {
                    val userDetails = userDetailsService.loadUserByUsername(email) // Fetch UserDetails

                    val auth = UsernamePasswordAuthenticationToken(userDetails, null, userDetails.authorities)
                    SecurityContextHolder.getContext().authentication = auth

                    // Store user ID in request attributes for controllers to access
                    request.setAttribute("user_id", userDetails.username)
                }
            } catch (e: Exception) {
                response.sendError(HttpServletResponse.SC_UNAUTHORIZED, "Invalid token: ${e.message}")
                return
            }
        }

        chain.doFilter(request, response)
    }
}
package com.donateraja.common.network

import com.donateraja.common.exception.ServiceException
import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import mu.KotlinLogging
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Lazy
import org.springframework.http.HttpEntity
import org.springframework.http.HttpMethod
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.stereotype.Component
import org.springframework.web.client.HttpStatusCodeException
import org.springframework.web.client.RestTemplate

@Component
class HttpServiceProvider(
    @Lazy
    private val restTemplate: RestTemplate
) {

    private val logger = KotlinLogging.logger {}
    private val objectMapper = jacksonObjectMapper().apply { findAndRegisterModules() }

    @Bean
    private fun restTemplateProvider(): RestTemplate = restTemplate

    /**
     * Performs an HTTP exchange and handles errors centrally.
     *
     * @param url The target URL.
     * @param method The HTTP method (GET, POST, etc.).
     * @param requestBody The request body (optional).
     * @param responseType The response type.
     * @param headers Additional HTTP headers (optional).
     * @return ResponseEntity of the expected response type.
     * @throws ServiceException if an error occurs during the HTTP call.
     */
    @Throws(ServiceException::class)
    fun <T> exchange(
        url: String,
        method: HttpMethod,
        httpEntity: HttpEntity<Any>,
        responseType: Class<T>,
        logPayloadAvailable: Boolean = true
    ): ResponseEntity<T> = try {
        logger.info { "Making $method request to URL: $url" }
        logRequestBody(httpEntity, logPayloadAvailable)
        restTemplateProvider().exchange(url, method, httpEntity, responseType)
    } catch (exception: HttpStatusCodeException) {
        // Log and rethrow as ServiceException for 4xx/5xx errors
        val httpStatus = HttpStatus.valueOf(exception.statusCode.value())
        logger.error("Url :$url status code :${exception.statusCode} message : ${exception.responseBodyAsString} ")
        throw ServiceException(httpStatus, exception.responseBodyAsString)
    } catch (exception: Exception) {
        // Log and rethrow for generic errors
        logger.error("Unexpected error during exchange to $url")
        throw ServiceException(HttpStatus.INTERNAL_SERVER_ERROR, exception.message)
    }

    /**
     * Logs the details of the request, including the URL, method, and a pretty-printed request body.
     */
    private fun logRequestBody(httpEntity: HttpEntity<Any>, logPayloadAvailable: Boolean) {
        if (logPayloadAvailable && httpEntity.hasBody()) {
            try {
                val prettyBody = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(httpEntity.body)
                logger.debug { "Request body: $prettyBody" }
            } catch (ex: Exception) {
                logger.error("unable to log the request body {}", ex.message)
            }
        }
    }
}
package com.donateraja.common.util

import com.donateraja.common.exception.ServiceException
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Component
import org.springframework.web.multipart.MultipartFile

@Component
class ImageValidator {

    fun validateUploadType(uploadType: String) {
        val allowedTypes = setOf("items", "profile", "documents")
        if (uploadType !in allowedTypes) {
            throw ServiceException(
                HttpStatus.BAD_REQUEST,
                "Invalid upload type. Allowed values: ${allowedTypes.joinToString()}"
            )
        }
    }

    fun validateImageFile(file: MultipartFile, uploadType: String, index: Int?) {
        val prefix = index?.let { "File #${it + 1}: " } ?: ""

        // Check empty file
        if (file.isEmpty) {
            throw ServiceException(HttpStatus.BAD_REQUEST, "${prefix}File is empty")
        }

        // Validate file size
        val maxSize = when (uploadType) {
            "profile" -> 2_000_000
            "documents" -> 10_000_000
            else -> 5_000_000 // items and others
        }
        if (file.size > maxSize) {
            throw ServiceException(
                HttpStatus.PAYLOAD_TOO_LARGE,
                "${prefix}File size exceeds ${maxSize / 1_000_000}MB limit"
            )
        }

        // Validate content type
        val allowedTypes = when (uploadType) {
            "profile" -> setOf("image/jpeg", "image/png")
            "items" -> setOf("image/jpeg", "image/png", "image/webp")
            "documents" -> setOf("application/pdf", "text/plain")
            else -> throw ServiceException(HttpStatus.INTERNAL_SERVER_ERROR, "Invalid upload type configuration")
        }

        val contentType = file.contentType ?: throw ServiceException(
            HttpStatus.BAD_REQUEST,
            "${prefix}File type not recognized"
        )

        if (contentType !in allowedTypes) {
            throw ServiceException(
                HttpStatus.UNSUPPORTED_MEDIA_TYPE,
                "${prefix}Invalid file type for $uploadType. Allowed: ${allowedTypes.joinToString()}"
            )
        }

        // Validate filename
        val fileName = file.originalFilename ?: throw ServiceException(
            HttpStatus.BAD_REQUEST,
            "${prefix}File name is missing"
        )

        if (fileName.contains("..") || fileName.contains("/")) {
            throw ServiceException(
                HttpStatus.BAD_REQUEST,
                "${prefix}Invalid file name"
            )
        }
    }

    fun getFileExtension(file: MultipartFile): String = file.originalFilename
        ?.substringAfterLast('.', "")
        ?.takeIf { it.isNotBlank() }
        ?: throw ServiceException(
            HttpStatus.BAD_REQUEST,
            "File extension is missing or invalid"
        )
}
package com.donateraja.common.util

import com.donateraja.common.exception.ServiceException
import com.donateraja.configuration.JwtTokenConfig
import com.donateraja.domain.auth.AuthResponse
import io.jsonwebtoken.Claims
import io.jsonwebtoken.ExpiredJwtException
import io.jsonwebtoken.JwtException
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.SignatureAlgorithm
import io.jsonwebtoken.security.Keys
import jakarta.annotation.PostConstruct
import org.springframework.http.HttpStatus
import org.springframework.security.core.Authentication
import org.springframework.security.core.GrantedAuthority
import org.springframework.stereotype.Service
import java.security.Key
import java.time.Duration
import java.time.Instant
import java.util.Base64
import java.util.Date
import java.util.Timer
import java.util.TimerTask
import java.util.concurrent.ConcurrentHashMap

@Service
class JwtUtil(private val jwtTokenConfig: JwtTokenConfig) {

    private val key: Key = Keys.hmacShaKeyFor(Base64.getDecoder().decode(jwtTokenConfig.base64Secret))

    @Throws(ServiceException::class)
    fun generateAccessToken(authentication: Authentication): AuthResponse =
        buildToken(authentication.name, authentication.authorities, parseDuration(jwtTokenConfig.accessTokenExpiration))

    @Throws(ServiceException::class)
    fun generateRefreshToken(authentication: Authentication): AuthResponse =
        buildToken(authentication.name, emptySet(), parseDuration(jwtTokenConfig.refreshTokenExpiration))

    private fun buildToken(userId: String, authorities: Collection<GrantedAuthority>, expiration: Duration): AuthResponse {
        val roles = authorities.map { it.authority }.ifEmpty { listOf("USER") }
        val claims = mapOf(
            "roles" to authorities.map { it.authority }.ifEmpty { listOf("USER") },
            "userId" to userId
        )
        val token = Jwts.builder()
            .setIssuer(jwtTokenConfig.issuer)
            .setSubject(userId)
            .setIssuedAt(Date.from(Instant.now()))
            .setExpiration(Date.from(Instant.now().plus(expiration)))
            .addClaims(claims)
            .signWith(key, SignatureAlgorithm.HS256)
            .compact()

        return AuthResponse(token, expiration.toMillis(), roles, claims, userId)
    }

    fun validateToken(token: String): Boolean = try {
        val claims = extractAllClaims(token)
        if (isBlacklisted(token)) {
            throw ServiceException(HttpStatus.UNAUTHORIZED, "Token revoked")
        }
        if (claims.expiration.before(Date())) {
            throw ServiceException(HttpStatus.UNAUTHORIZED, "Token expired, please refresh")
        }
        true
    } catch (e: ExpiredJwtException) {
        throw ServiceException(HttpStatus.UNAUTHORIZED, "Token expired, please refresh")
    } catch (e: JwtException) {
        throw ServiceException(HttpStatus.FORBIDDEN, "Invalid token")
    }

    fun extractUsername(token: String): String = extractClaim(token) { it.subject }

    fun extractRoles(token: String): List<String> = try {
        extractClaim(token) { claims ->
            claims["roles"]?.let { it as List<*> }?.mapNotNull { it as? String } ?: emptyList()
        }
    } catch (e: Exception) {
        emptyList()
    }

    fun <T> extractClaim(token: String, claimsResolver: (Claims) -> T): T = claimsResolver(extractAllClaims(token))

    fun extractAllClaims(token: String): Claims = Jwts.parserBuilder().setSigningKey(key).build().parseClaimsJws(token).body

    fun isTokenExpired(token: String): Boolean = try {
        val claims = extractAllClaims(token)
        claims.expiration.before(Date())
    } catch (e: ExpiredJwtException) {
        true
    }

    fun parseDuration(duration: String): Duration {
        val pattern = Regex("(\\d+)([hmsd])")
        val matchResult = pattern.find(duration) ?: throw IllegalArgumentException("Invalid duration format: $duration")
        val amount = matchResult.groupValues[1].toLong()
        return when (matchResult.groupValues[2]) {
            "h" -> Duration.ofHours(amount)
            "m" -> Duration.ofMinutes(amount)
            "s" -> Duration.ofSeconds(amount)
            "d" -> Duration.ofDays(amount)
            else -> throw IllegalArgumentException("Unsupported time unit in duration: $duration")
        }
    }

    // Add token blacklist component
    private val tokenBlacklist = ConcurrentHashMap<String, Instant>()

    // Add scheduled cleanup for blacklisted tokens
    @PostConstruct
    fun init() {
        Timer().scheduleAtFixedRate(
            object : TimerTask() {
                override fun run() {
                    cleanExpiredBlacklistedTokens()
                }
            },
            0,
            60 * 60 * 1000
        ) // Clean hourly
    }

    // Add to existing class
    fun addToBlacklist(token: String) {
        val expiration = extractAllClaims(token).expiration.toInstant()
        if (expiration.isAfter(Instant.now())) {
            tokenBlacklist[token] = expiration
        }
    }

    fun isBlacklisted(token: String): Boolean = tokenBlacklist[token]?.isAfter(Instant.now()) ?: false

    private fun cleanExpiredBlacklistedTokens() {
        val now = Instant.now()
        tokenBlacklist.entries.removeIf { entry -> entry.value.isBefore(now) }
    }
}
package com.donateraja.common.util

import org.slf4j.MDC
import org.springframework.http.HttpStatus
import org.springframework.web.server.ResponseStatusException

object SecurityContextUtil {
    fun getUserIdFromContext(): String =
        MDC.get("user_id") ?: throw ResponseStatusException(HttpStatus.UNAUTHORIZED, "User context not found")
}
package com.donateraja.common.util

import com.donateraja.entity.user.User
import com.donateraja.repository.UserRepository
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import org.springframework.stereotype.Component

@Component
class UserLookupUtil(private val userRepository: UserRepository) : UserDetailsService {

    override fun loadUserByUsername(username: String): UserDetails {
        val user: User? = when {
            username.contains("@") -> userRepository.findByEmail(username)
            username.all { it.isDigit() } -> {
                userRepository.findByPhoneNumber(username)
                    ?: username.toLongOrNull()?.let { userRepository.findById(it).orElse(null) }
            }
            else -> null
        }

        return user ?: throw UsernameNotFoundException("User not found with identifier: $username")
    }
}
package com.donateraja.configuration

import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Configuration

@Configuration
class BackblazeConfig(
    @Value("\${backblaze.applicationKeyId}") val applicationKeyId: String,
    @Value("\${backblaze.applicationKey}") val applicationKey: String,
    @Value("\${backblaze.bucketId}") val bucketId: String,
    @Value("\${backblaze.publicBaseUrl}") val publicBaseUrl: String
)
package com.donateraja.configuration

import org.slf4j.Logger
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Configuration
import java.time.Duration
import java.util.*

@Configuration
class JwtTokenConfig(
    @Value("\${spring.security.jwt.base64-signing-key}")
    val base64Secret: String,

    @Value("\${spring.security.jwt.access-token-expiration}")
    val accessTokenExpiration: String,

    @Value("\${spring.security.jwt.refresh-token-expiration}")
    val refreshTokenExpiration: String,

    @Value("\${spring.security.jwt.issuer}")
    val issuer: String
) {

    private val logger: Logger = LoggerFactory.getLogger(JwtTokenConfig::class.java)

    init {
        // Debug: Print values for verification (remove in production)
        logger.debug("Loaded base64Secret: $base64Secret")
        logger.debug("Loaded accessTokenExpiration: $accessTokenExpiration")
        logger.debug("Loaded refreshTokenExpiration: $refreshTokenExpiration")
        logger.debug("Loaded issuer: $issuer")

        // Ensure the base64 secret is at least 256 bits (32 bytes)
        require(Base64.getDecoder().decode(base64Secret).size >= 32) {
            "Signing key must be at least 256-bit (32 bytes)"
        }
    }

    /**
     * Parse the duration string (e.g., 1h, 7d) into a Duration object.
     */
    fun parseDuration(duration: String): Duration {
        return when {
            duration.endsWith("h") -> Duration.ofHours(duration.replace("h", "").toLong())
            duration.endsWith("d") -> Duration.ofDays(duration.replace("d", "").toLong())
            else -> throw IllegalArgumentException("Invalid duration format")
        }
    }
}
package com.donateraja.configuration.openapi

import io.swagger.v3.oas.models.Components
import io.swagger.v3.oas.models.OpenAPI
import io.swagger.v3.oas.models.info.Info
import io.swagger.v3.oas.models.security.SecurityRequirement
import io.swagger.v3.oas.models.security.SecurityScheme
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration

@Configuration
class SwaggerConfig {

    @Value("\${spring.application.name}")
    lateinit var appName: String

    @Value("\${spring.application.description}")
    lateinit var appDescription: String

    @Value("\${spring.application.version}")
    lateinit var appVersion: String

    @Bean
    fun customOpenAPI(): OpenAPI {
        return OpenAPI()
            .info(
                Info()
                    .title(appName)
                    .description(appDescription)
                    .version(appVersion)
            )
            .addSecurityItem(SecurityRequirement().addList("bearerAuth"))
            .components(
                Components().addSecuritySchemes(
                    "bearerAuth",
                    SecurityScheme()
                        .type(SecurityScheme.Type.HTTP)
                        .scheme("bearer")
                        .bearerFormat("JWT")
                )
            )
    }
}
package com.donateraja.configuration

import com.donateraja.common.filter.JwtAuthenticationFilter
import com.donateraja.common.util.UserLookupUtil
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.AuthenticationProvider
import org.springframework.security.authentication.dao.DaoAuthenticationProvider
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
class SecurityConfig(
    private val jwtAuthenticationFilter: JwtAuthenticationFilter
//    , private val validationFilter: ValidationFilter
) {

    companion object {
        private val PUBLIC_URLS = arrayOf(
            "/auth/**",
            "/swagger-ui.html",
            "/swagger-ui/**",
            "/v3/api-docs/**",
            "/swagger-resources/**",
            "/configuration/**",
            "/webjars/**"
        )
    }

    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http
            .csrf { it.disable() }
            .authorizeHttpRequests { requests ->
                requests
                    .requestMatchers(*PUBLIC_URLS).permitAll()
                    .anyRequest().authenticated()
            }
            .sessionManagement { session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            }
//            .addFilterBefore(validationFilter, UsernamePasswordAuthenticationFilter::class.java)
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter::class.java)

        return http.build()
    }

    @Bean
    fun authenticationProvider(userDetailsService: UserLookupUtil, passwordEncoder: PasswordEncoder): AuthenticationProvider {
        val authProvider = DaoAuthenticationProvider()
        authProvider.setUserDetailsService(userDetailsService)
        authProvider.setPasswordEncoder(passwordEncoder)
        return authProvider
    }

    @Bean
    fun authenticationManager(authConfig: AuthenticationConfiguration): AuthenticationManager = authConfig.authenticationManager

    @Bean
    fun passwordEncoder(): PasswordEncoder = BCryptPasswordEncoder()
}
package com.donateraja.controller

import ApiOperationWithCustomResponses
import com.donateraja.common.exception.ServiceException
import com.donateraja.domain.auth.AuthRequest
import com.donateraja.domain.auth.AuthResponse
import com.donateraja.domain.user.UserRegistrationRequest
import com.donateraja.service.AuthService
import io.swagger.v3.oas.annotations.tags.Tag
import org.slf4j.LoggerFactory
import org.springframework.http.ResponseEntity
import org.springframework.validation.annotation.Validated
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestHeader
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/auth")
@Tag(name = "Authentication", description = "APIs related to User Authentication, Login, and Registration")
@Validated
class AuthController(private val authService: AuthService) {

    private val logger = LoggerFactory.getLogger(AuthController::class.java)

    @ApiOperationWithCustomResponses(
        summary = "Register a new user",
        description = "Creates a new user account and returns an authentication token.",
        successSchema = AuthResponse::class
    )
    @PostMapping("/register")
    fun register(@Validated @RequestBody userRegistrationRequest: UserRegistrationRequest): ResponseEntity<AuthResponse> {
        logger.info("User registration attempt: ${userRegistrationRequest.email}")
        val token = authService.registerUser(userRegistrationRequest)
        logger.info("User registered successfully: ${userRegistrationRequest.email}")
        return ResponseEntity.ok(token)
    }

    @ApiOperationWithCustomResponses(
        summary = "User login",
        description = "Authenticates user and returns JWT token.",
        successSchema = AuthResponse::class
    )
    @Throws(ServiceException::class)
    @PostMapping("/login")
    fun login(@Validated @RequestBody authRequest: AuthRequest): ResponseEntity<AuthResponse> {
        logger.info("User login attempt: ${authRequest.identifier}")
        val token = authService.loginUser(authRequest)
        logger.info("User logged in successfully: ${authRequest.identifier}")
        return ResponseEntity.ok(token)
    }

    @ApiOperationWithCustomResponses(summary = "User logout", description = "Logs out the user by clearing security context.")
    @PostMapping("/logout")
    fun logout(@RequestHeader("Authorization") token: String): ResponseEntity<String> {
        authService.logoutUser(token)
        return ResponseEntity.ok("Logout successful. Please discard the token on the client-side.")
    }

    @ApiOperationWithCustomResponses(summary = "User logout", description = "Logs out the user by clearing security context.")
    @PostMapping("/refresh")
    fun refreshToken(@RequestHeader("Authorization") token: String): ResponseEntity<AuthResponse> {
        val authResponse = authService.refreshToken(token)
        return ResponseEntity.ok(authResponse)
    }
}
package com.donateraja.controller

import ApiOperationWithCustomResponses
import com.donateraja.service.ImageService
import jakarta.validation.constraints.NotBlank
import org.springframework.http.MediaType
import org.springframework.validation.annotation.Validated
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.multipart.MultipartFile

@Validated
@RestController
@RequestMapping("/api/images")
class ImageController(private val imageService: ImageService) {

    @PostMapping(
        value = ["/upload"],
        consumes = [MediaType.MULTIPART_FORM_DATA_VALUE]
    )
    @ApiOperationWithCustomResponses(
        summary = "Upload multiple images",
        description = "Upload images for items or other content. Max 5 files per request, 5MB each.",
        successSchema = List::class
    )
    fun uploadImages(
        @RequestParam("files") files: List<MultipartFile>,
        @RequestParam("uploadType") @NotBlank uploadType: String
    ): List<String> = imageService.uploadImages(files, uploadType)

    @PostMapping(
        value = ["/upload/profile"],
        consumes = [MediaType.MULTIPART_FORM_DATA_VALUE]
    )
    @ApiOperationWithCustomResponses(
        summary = "Upload profile picture",
        description = "Upload a single profile picture. Max size 2MB.",
        successSchema = String::class
    )
    fun uploadProfilePicture(@RequestParam("file") file: MultipartFile): String = imageService.uploadProfilePicture(file)
}
package com.donateraja.controller

import ApiOperationWithCustomResponses
import com.donateraja.annotation.RequireUser
import com.donateraja.domain.item.ItemCreateDTO
import com.donateraja.domain.item.ItemResponseDTO
import com.donateraja.domain.item.ItemStatusDTO
import com.donateraja.domain.item.ItemUpdateDTO
import com.donateraja.entity.constants.Category
import com.donateraja.entity.constants.DonationOrRent
import com.donateraja.service.ItemService
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.DeleteMapping
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PatchMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/items")
@Tag(name = "Item Management", description = "Manage items for donation or rental")
class ItemController(private val itemService: ItemService) {

    @PostMapping
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Post new item",
        description = "Allows users to post an item for donation or rental.",
        successSchema = ItemResponseDTO::class
    )
    fun postItem(@RequestBody itemCreateDTO: ItemCreateDTO): ResponseEntity<ItemResponseDTO> =
        ResponseEntity.ok(itemService.postItem(itemCreateDTO))

    @GetMapping("/{itemId}")
    @ApiOperationWithCustomResponses(
        summary = "Get item details",
        description = "Retrieves details of a specific item.",
        successSchema = ItemResponseDTO::class
    )
    fun getItem(@PathVariable itemId: Long): ResponseEntity<ItemResponseDTO> = ResponseEntity.ok(itemService.getItem(itemId))

    @PutMapping("/{itemId}")
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Update item",
        description = "Allows users to update an existing item.",
        successSchema = ItemResponseDTO::class
    )
    fun updateItem(@PathVariable itemId: Long, @RequestBody itemUpdateDTO: ItemUpdateDTO): ResponseEntity<ItemResponseDTO> =
        ResponseEntity.ok(itemService.updateItem(itemId, itemUpdateDTO))

    @DeleteMapping("/{itemId}")
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Delete item",
        description = "Removes an item from the platform.",
        successSchema = Unit::class
    )
    fun deleteItem(@PathVariable itemId: Long): ResponseEntity<Void> {
        itemService.deleteItem(itemId)
        return ResponseEntity.noContent().build()
    }

    @PatchMapping("/{itemId}/status")
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Update item status",
        description = "Updates the status of an existing item.",
        successSchema = ItemResponseDTO::class
    )
    fun updateItemStatus(@PathVariable itemId: Long, @RequestBody itemStatusDTO: ItemStatusDTO): ResponseEntity<ItemResponseDTO> =
        ResponseEntity.ok(itemService.updateItemStatus(itemId, itemStatusDTO))

    @GetMapping("/search")
    @ApiOperationWithCustomResponses(
        summary = "Search items by pincode",
        description = "Finds items based on location, category, and donation/rental type.",
        successSchema = Array<ItemResponseDTO>::class
    )
    fun searchItemsByPincode(
        @RequestParam pincode: String,
        @RequestParam(required = false) category: Category?,
        @RequestParam(required = false) donationOrRent: DonationOrRent?
    ): ResponseEntity<List<ItemResponseDTO>> =
        ResponseEntity.ok(itemService.searchItemsByPincode(pincode, category, donationOrRent))
}
package com.donateraja.controller

import ApiOperationWithCustomResponses
import com.donateraja.domain.request.ItemRequestCreateDTO
import com.donateraja.domain.request.ItemRequestResponseDTO
import com.donateraja.domain.request.ItemRequestStatusDTO
import com.donateraja.service.ItemRequestService
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PatchMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/requests")
class ItemRequestController(private val itemRequestService: ItemRequestService) {

    @PostMapping("/items")
    @ApiOperationWithCustomResponses(
        summary = "Create item request",
        description = "Creates a new request for donation or rental.",
        successSchema = ItemRequestResponseDTO::class
    )
    fun createRequest(@RequestBody requestCreateDTO: ItemRequestCreateDTO): ResponseEntity<ItemRequestResponseDTO> =
        ResponseEntity.ok(itemRequestService.createRequest(requestCreateDTO))

    @GetMapping("/{requestId}")
    @ApiOperationWithCustomResponses(
        summary = "Get item request",
        description = "Fetches an item request by ID.",
        successSchema = ItemRequestResponseDTO::class
    )
    fun getRequest(@PathVariable requestId: Long): ResponseEntity<ItemRequestResponseDTO> =
        ResponseEntity.ok(itemRequestService.getRequestById(requestId))

    @PatchMapping("/{requestId}")
    @ApiOperationWithCustomResponses(
        summary = "Update request status",
        description = "Updates the status of an item request.",
        successSchema = ItemRequestResponseDTO::class
    )
    fun updateRequestStatus(
        @PathVariable requestId: Long,
        @RequestBody requestStatusDTO: ItemRequestStatusDTO
    ): ResponseEntity<ItemRequestResponseDTO> =
        ResponseEntity.ok(itemRequestService.updateRequestStatus(requestId, requestStatusDTO))

    @GetMapping("/me/sent")
    @ApiOperationWithCustomResponses(
        summary = "Get user's sent requests",
        description = "Retrieves all item requests sent by the user.",
        successSchema = List::class
    )
    fun getSentRequests(@RequestParam userId: Long): ResponseEntity<List<ItemRequestResponseDTO>> =
        ResponseEntity.ok(itemRequestService.getSentRequests(userId))

    @GetMapping("/me/received")
    @ApiOperationWithCustomResponses(
        summary = "Get user's received requests",
        description = "Retrieves all item requests received by the user.",
        successSchema = List::class
    )
    fun getReceivedRequests(@RequestParam userId: Long): ResponseEntity<List<ItemRequestResponseDTO>> =
        ResponseEntity.ok(itemRequestService.getReceivedRequests(userId))
}
package com.donateraja.controller

import com.donateraja.annotation.PublicAccess
import com.donateraja.annotation.RequireAdmin
import com.donateraja.annotation.RequireUser
import com.donateraja.annotation.RequireUserOrAdmin
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RestController

@RestController
@RequestMapping("/api")
class TestController {

    @GetMapping("/public")
    @PublicAccess
    fun publicEndpoint(): String = "Public API: No Authentication Required"

    @GetMapping("/user")
    @RequireUser
    fun userEndpoint(): String = "User API: Accessible only by Users"

    @GetMapping("/admin")
    @RequireAdmin
    fun adminEndpoint(): String = "Admin API: Accessible only by Admins"

    @GetMapping("/user-or-admin")
    @RequireUserOrAdmin
    fun userOrAdminEndpoint(): String = "User or Admin API: Accessible by both Users and Admins"
}
package com.donateraja.controller

import ApiOperationWithCustomResponses
import com.donateraja.annotation.RequireUser
import com.donateraja.model.user.ChangePasswordDto
import com.donateraja.model.user.UserProfileDto
import com.donateraja.model.user.UserRegistrationResponse
import com.donateraja.service.impl.UserServiceImpl
import io.swagger.v3.oas.annotations.tags.Tag
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.GetMapping
import org.springframework.web.bind.annotation.PatchMapping
import org.springframework.web.bind.annotation.PathVariable
import org.springframework.web.bind.annotation.PostMapping
import org.springframework.web.bind.annotation.PutMapping
import org.springframework.web.bind.annotation.RequestBody
import org.springframework.web.bind.annotation.RequestMapping
import org.springframework.web.bind.annotation.RequestParam
import org.springframework.web.bind.annotation.RestController
import org.springframework.web.multipart.MultipartFile

@RestController
@RequestMapping("/users")
@Tag(name = "User Management", description = "APIs related to User Management")
class UserController(private val userService: UserServiceImpl) {

    @GetMapping("/me")
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Get current user profile",
        description = "Fetches the logged-in user's profile.",
        successSchema = UserProfileDto::class
    )
    fun getCurrentUserProfile(): ResponseEntity<UserProfileDto> {
        val userProfile = userService.getCurrentUserProfile()
        return ResponseEntity(userProfile, HttpStatus.OK)
    }

    @PutMapping("/me")
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Update profile",
        description = "Updates the logged-in user's profile.",
        successSchema = UserProfileDto::class
    )
    fun updateProfile(@RequestBody userUpdateDTO: UserProfileDto): ResponseEntity<UserProfileDto> {
        val updatedProfile = userService.updateUserProfile(userUpdateDTO)
        return ResponseEntity(updatedProfile, HttpStatus.OK)
    }

    @PutMapping("/me/password")
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Change password",
        description = "Allows the logged-in user to change their password."
    )
    fun changePassword(@RequestBody changePasswordDto: ChangePasswordDto): ResponseEntity<Any> {
        userService.changePassword(changePasswordDto)
        return ResponseEntity(HttpStatus.OK)
    }

    @PatchMapping("/me/avatar")
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Update profile picture",
        description = "Updates the logged-in user's profile picture.",
        successSchema = UserProfileDto::class
    )
    fun updateProfilePicture(@RequestParam("file") file: MultipartFile): ResponseEntity<UserProfileDto> {
        val updatedProfile = userService.updateProfilePicture(file)
        return ResponseEntity(updatedProfile, HttpStatus.OK)
    }

    @GetMapping("/{userId}")
    @ApiOperationWithCustomResponses(
        summary = "Get public user profile",
        description = "Fetches the public profile of a user.",
        successSchema = UserProfileDto::class
    )
    fun getPublicUserProfile(@PathVariable userId: Long): ResponseEntity<UserProfileDto> {
        val userProfile = userService.getUserProfile(userId)
        return ResponseEntity(userProfile, HttpStatus.OK)
    }

    @PostMapping("/{userId}/verify-email")
    @RequireUser
    @ApiOperationWithCustomResponses(
        summary = "Resend verification email",
        description = "Resends the email verification link to the user.",
        successSchema = UserRegistrationResponse::class
    )
    fun resendVerificationEmail(@PathVariable userId: Long): ResponseEntity<UserRegistrationResponse> {
        val response = userService.resendVerificationEmail(userId)
        return ResponseEntity(response, HttpStatus.OK)
    }
}
package com.donateraja.domain.auth

import com.fasterxml.jackson.annotation.JsonProperty
import io.swagger.v3.oas.annotations.media.Schema
import jakarta.validation.constraints.NotBlank

class AuthRequest {
    @Schema(
        description = "User identifier, which can be an Email, Phone Number, or Customer ID",
        example = "user@example.com"
    )
    @JsonProperty("identifier")
    @NotBlank(message = "Identifier cannot be null or blank")
    var identifier: String? = null

    @Schema(
        description = "User password",
        example = "password123"
    )
    @JsonProperty("password")
    @NotBlank(message = "Password cannot be null or blank")
    var password: String? = null

    constructor(identifier: String, password: String) {
        this.identifier = identifier
        this.password = password
    }

    constructor()
    override fun toString(): String = "AuthRequest(identifier='$identifier', password='****')"
}
package com.donateraja.domain.auth

data class AuthResponse(
    val token: String? = null,
    val expiresIn: Long? = null,
    val roles: List<String>? = null,
    val claims: Map<String, Any>? = null,
    val userId: String? = null
//    val tokenType: String
)
package com.donateraja.domain.item

import com.donateraja.entity.constants.Category
import com.donateraja.entity.constants.Condition
import com.donateraja.entity.constants.DonationOrRent
import com.fasterxml.jackson.annotation.JsonProperty
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Positive
import jakarta.validation.constraints.Size

class ItemCreateDTO {

    @JsonProperty("item_name")
    @NotBlank(message = "item_name cannot be null or blank")
    @Size(max = 100)
    var itemName: String? = null

    @JsonProperty("description")
    @NotBlank(message = "description cannot be null or blank")
    @Size(max = 1000)
    var description: String? = null

    @JsonProperty("condition")
    @NotNull(message = "condition cannot be null")
    var condition: Condition? = null

    @JsonProperty("price")
    @Positive(message = "price must be positive")
    var price: Double? = null

    @JsonProperty("location")
    @NotBlank(message = "location cannot be null or blank")
    var location: String? = null

    @JsonProperty("pincode")
    @NotBlank(message = "pincode cannot be null or blank")
    var pincode: String? = null

    @JsonProperty("category")
    @NotNull(message = "category cannot be null")
    var category: Category? = null

    @JsonProperty("donation_or_rent")
    @NotNull(message = "donation_or_rent cannot be null")
    var donationOrRent: DonationOrRent? = null

    @JsonProperty("user_id")
    @NotNull(message = "user cannot be null")
    var userId: Long? = null

    @JsonProperty("image_urls")
    var imageUrls: List<String> = emptyList()

    @JsonProperty("tags")
    var tags: List<String> = emptyList()

    constructor()

    constructor(
        itemName: String,
        description: String,
        condition: Condition,
        price: Double,
        location: String,
        pincode: String,
        category: Category,
        donationOrRent: DonationOrRent,
        userId: Long
    ) {
        this.itemName = itemName
        this.description = description
        this.condition = condition
        this.price = price
        this.location = location
        this.pincode = pincode
        this.category = category
        this.donationOrRent = donationOrRent
        this.userId = userId
        this.imageUrls = imageUrls
        this.tags = tags
    }
}
package com.donateraja.domain.item

import com.donateraja.entity.constants.Category
import com.donateraja.entity.constants.Condition
import com.donateraja.entity.constants.DonationOrRent
import com.donateraja.entity.constants.ItemStatus
import com.fasterxml.jackson.annotation.JsonProperty
import java.time.LocalDateTime

data class ItemResponseDTO(
    @JsonProperty("id") val id: Long,
    @JsonProperty("item_name") val itemName: String,
    @JsonProperty("description") val description: String,
    @JsonProperty("condition") val condition: Condition,
    @JsonProperty("price") val price: Double,
    @JsonProperty("location") val location: String,
    @JsonProperty("pincode") val pincode: String,
    @JsonProperty("category") val category: Category,
    @JsonProperty("donation_or_rent") val donationOrRent: DonationOrRent,
    @JsonProperty("status") val status: ItemStatus,
    @JsonProperty("created_at") val createdAt: LocalDateTime,
    @JsonProperty("updated_at") val updatedAt: LocalDateTime,
    @JsonProperty("image_urls") val imageUrls: List<String>,
    @JsonProperty("tags") val tags: List<String>
) {
    // Secondary constructor for compatibility (if needed)
    constructor(
        id: Long,
        itemName: String,
        description: String,
        condition: Condition,
        price: Double,
        location: String,
        pincode: String,
        category: Category,
        donationOrRent: DonationOrRent,
        status: ItemStatus,
        createdAt: LocalDateTime,
        updatedAt: LocalDateTime
    ) : this(
        id, itemName, description, condition, price, location, pincode,
        category, donationOrRent, status, createdAt, updatedAt, emptyList(), emptyList()
    )
}
package com.donateraja.domain.item

import com.donateraja.entity.constants.ItemStatus
import com.fasterxml.jackson.annotation.JsonProperty
import jakarta.validation.constraints.NotNull

class ItemStatusDTO {

    @JsonProperty("status")
    @NotNull(message = "status cannot be null")
    var status: ItemStatus? = null

    constructor()

    constructor(status: ItemStatus) {
        this.status = status
    }
}
package com.donateraja.domain.item

import com.fasterxml.jackson.annotation.JsonProperty
import jakarta.validation.constraints.Positive
import jakarta.validation.constraints.Size

class ItemUpdateDTO {

    @JsonProperty("item_name")
    @Size(max = 100)
    var itemName: String? = null

    @JsonProperty("description")
    @Size(max = 1000)
    var description: String? = null

    @JsonProperty("price")
    @Positive(message = "price must be positive")
    var price: Double? = null

    constructor()

    constructor(
        itemName: String?,
        description: String?,
        price: Double?
    ) {
        this.itemName = itemName
        this.description = description
        this.price = price
    }
}
package com.donateraja.domain.request

import com.donateraja.entity.constants.RequestStatus
import com.donateraja.entity.constants.RequestType
import com.fasterxml.jackson.annotation.JsonProperty
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.NotNull
import java.time.LocalDateTime

class ItemRequestCreateDTO {

    @JsonProperty("user_id")
    @NotNull(message = "User ID cannot be null")
    var userId: Long? = null

    @JsonProperty("item_id")
    @NotNull(message = "Item ID cannot be null")
    var itemId: Long? = null

    @JsonProperty("request_type")
    @NotBlank(message = "Request type cannot be blank")
    var requestType: RequestType? = RequestType.RENTAL // Values: "DONATION" or "RENTAL"

    @JsonProperty("message")
    var message: String? = null

    @JsonProperty("rental_start_date")
    var rentalStartDate: LocalDateTime? = null // Only for rental requests

    @JsonProperty("rental_end_date")
    var rentalEndDate: LocalDateTime? = null // Only for rental requests

    @JsonProperty("status")
    @NotNull(message = "Status cannot be null")
    var status: RequestStatus? = null

    constructor()

    constructor(
        userId: Long,
        itemId: Long,
        requestType: RequestType,
        message: String?,
        rentalStartDate: LocalDateTime?,
        rentalEndDate: LocalDateTime?,
        status: RequestStatus
    ) {
        this.userId = userId
        this.itemId = itemId
        this.requestType = requestType
        this.message = message
        this.rentalStartDate = rentalStartDate
        this.rentalEndDate = rentalEndDate
        this.status = status
    }
}
package com.donateraja.domain.request

import com.donateraja.entity.constants.RequestStatus
import com.donateraja.entity.constants.RequestType
import com.fasterxml.jackson.annotation.JsonProperty
import java.time.LocalDateTime

class ItemRequestResponseDTO {

    @JsonProperty("id")
    var id: Long = 0

    @JsonProperty("user_id")
    var userId: Long = 0

    @JsonProperty("item_id")
    var itemId: Long = 0

    @JsonProperty("request_type")
    var requestType: RequestType = RequestType.RENTAL

    @JsonProperty("message")
    var message: String = ""

    // Only for rental requests
    @JsonProperty("rental_start_date")
    var rentalStartDate: LocalDateTime? = null

    // Only for rental requests
    @JsonProperty("rental_end_date")
    var rentalEndDate: LocalDateTime? = null

    @JsonProperty("status")
    var status: RequestStatus = RequestStatus.PENDING

    @JsonProperty("created_at")
    var createdAt: LocalDateTime = LocalDateTime.now()

    @JsonProperty("updated_at")
    var updatedAt: LocalDateTime = LocalDateTime.now()

    constructor()

    constructor(
        id: Long,
        userId: Long,
        itemId: Long,
        requestType: RequestType,
        message: String,
        rentalStartDate: LocalDateTime?,
        rentalEndDate: LocalDateTime?,
        status: RequestStatus,
        createdAt: LocalDateTime,
        updatedAt: LocalDateTime
    ) {
        this.id = id
        this.userId = userId
        this.itemId = itemId
        this.requestType = requestType
        this.message = message
        this.rentalStartDate = rentalStartDate
        this.rentalEndDate = rentalEndDate
        this.status = status
        this.createdAt = createdAt
        this.updatedAt = updatedAt
    }
}
package com.donateraja.domain.request

import com.donateraja.entity.constants.RequestStatus
import com.fasterxml.jackson.annotation.JsonProperty
import jakarta.validation.constraints.NotNull

class ItemRequestStatusDTO {

    @JsonProperty("status")
    @NotNull(message = "Status cannot be null")
    var status: RequestStatus? = null

    constructor()

    constructor(status: RequestStatus) {
        this.status = status
    }
}
package com.donateraja.domain.user

class AddressResponseDTO(val street: String, val city: String, val state: String, val pincode: String, val country: String)
package com.donateraja.domain.user

import com.fasterxml.jackson.annotation.JsonProperty
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern

class AddressUpdateDTO {
    @JsonProperty("street")
    @NotBlank(message = "street cannot be blank")
    var street: String? = null

    @JsonProperty("city")
    @NotBlank(message = "city cannot be blank")
    var city: String? = null

    @JsonProperty("state")
    @NotBlank(message = "state cannot be blank")
    var state: String? = null

    @JsonProperty("pincode")
    @NotBlank(message = "pincode cannot be blank")
    @Pattern(regexp = "^[1-9][0-9]{5}$", message = "Invalid pincode format")
    var pincode: String? = null

    @JsonProperty("country")
    @NotBlank(message = "country cannot be blank")
    var country: String? = null
}
package com.donateraja.domain.user

import com.fasterxml.jackson.annotation.JsonProperty
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Pattern
import jakarta.validation.constraints.Size

class UserRegistrationRequest {

    @JsonProperty("username")
    @NotBlank(message = "username cannot be null or blank")
    @Size(max = 50)
    var username: String? = null

    @JsonProperty("email")
    @NotBlank(message = "Email cannot be null or blank")
    @Email
    @Size(max = 100)
    var email: String? = null

    @JsonProperty("phone_number")
    @NotBlank(message = "phone_number cannot be null or blank")
    @Pattern(regexp = "^\\+?[1-9]\\d{1,14}$", message = "Invalid phone number")
    var phoneNumber: String? = null

    @JsonProperty("password")
    @NotBlank(message = "password  cannot be null or blank")
    @Size(min = 6, max = 255, message = "password must be min 8 character long")
    var password: String? = null

    @JsonProperty("first_name")
    @NotBlank(message = "first_name  cannot be null or blank")
    var firstName: String? = null

    @JsonProperty("last_name")
    @NotBlank(message = "last_name cannot be null or blank")
    var lastName: String = ""

    @JsonProperty("pincode")
    @NotBlank(message = "pincode cannot be null or blank")
    @Pattern(regexp = "^[1-9][0-9]{5}$", message = "Invalid pincode format")
    var pincode: String? = null

    constructor()

    constructor(
        username: String,
        email: String,
        phoneNumber: String?,
        password: String,
        firstName: String,
        lastName: String,
        pincode: String
    ) {
        this.username = username
        this.email = email
        this.phoneNumber = phoneNumber
        this.password = password
        this.firstName = firstName
        this.lastName = lastName
        this.pincode = pincode
    }
}
package com.donateraja.entity

import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity
@Table(name = "categories")
data class Category(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val categoryId: Long? = null,

    val name: String,

    val description: String
)
package com.donateraja.entity

import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity
@Table(name = "conditions")
data class Condition(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val conditionId: Long? = null,

    val name: String,

    val description: String
)
package com.donateraja.entity.constants

enum class Category {
    ELECTRONICS,
    FURNITURE,
    BOOKS,
    CLOTHING,
    HOME_APPLIANCES,
    SPORTS,
    TOYS,
    VEHICLES,
    MUSIC_INSTRUMENTS,
    HEALTH_CARE,
    OFFICE_SUPPLIES,
    ART_CRAFTS,
    PET_SUPPLIES,
    BABY_PRODUCTS,
    JEWELRY,
    FOOTWEAR,
    GARDENING,
    BEAUTY_CARE,
    KITCHENWARE,
    EDUCATIONAL,
    MISCELLANEOUS
}
package com.donateraja.entity.constants

enum class Condition {
    NEW,
    USED,
    REFURBISHED
}
package com.donateraja.entity.constants

enum class DonationOrRent {
    DONATE,
    RENT
}
package com.donateraja.entity.constants

enum class Gender {
    MALE,
    FEMALE,
    OTHER,
    PREFER_NOT_TO_SAY
}
package com.donateraja.entity.constants

enum class ItemStatus {
    AVAILABLE,
    RESERVED,
    TAKEN
}
package com.donateraja.entity.constants

enum class RequestStatus {
    PENDING,
    APPROVED,
    REJECTED,
    CANCELLED
}
package com.donateraja.entity.constants

enum class RequestType {
    DONATION,
    RENTAL
}
package com.donateraja.entity.constants

enum class Role {
    USER,
    ADMIN
}
package com.donateraja.entity.constants

enum class UserStatus {
    ACTIVE,
    INACTIVE,
    BANNED,
    BLOCKED
}
package com.donateraja.entity

import com.donateraja.entity.item.Item
import com.donateraja.entity.user.User
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "donation_requests")
data class DonationRequest(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val requestId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "user_id")
    val user: User,

    @ManyToOne
    @JoinColumn(name = "item_id")
    val item: Item,

    val requestDate: LocalDateTime,

    val status: String
)
package com.donateraja.entity

import com.donateraja.entity.item.Item
import com.donateraja.entity.user.User
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "favorites")
data class Favorite(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val favoriteId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "user_id")
    val user: User,

    @ManyToOne
    @JoinColumn(name = "item_id")
    val item: Item,

    val createdAt: LocalDateTime
)
package com.donateraja.entity.item

import com.donateraja.entity.constants.Category
import com.donateraja.entity.constants.Condition
import com.donateraja.entity.constants.DonationOrRent
import com.donateraja.entity.constants.ItemStatus
import com.donateraja.entity.user.User
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "items")
class Item(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var id: Long = 0,

    @Column(nullable = false)
    var itemName: String = "",

    @Column(nullable = false, length = 1000)
    var description: String = "",

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var condition: Condition = Condition.NEW,

    @Column(nullable = false)
    var price: Double = 0.0,

    @Column(nullable = false)
    var location: String = "",

    @Column(nullable = false)
    var pincode: String = "",

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var category: Category = Category.ELECTRONICS,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var donationOrRent: DonationOrRent = DonationOrRent.RENT,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var status: ItemStatus = ItemStatus.AVAILABLE,

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    var user: User,

    @Column(name = "created_at", updatable = false)
    var createdAt: LocalDateTime = LocalDateTime.now(),

    @Column(name = "updated_at")
    var updatedAt: LocalDateTime = LocalDateTime.now()
)
import com.donateraja.entity.user.User
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.math.BigDecimal
import java.time.LocalDateTime

@Entity
@Table(name = "item_history")
class ItemHistory {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    var itemId: Long? = null

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    lateinit var user: User

    lateinit var title: String
    lateinit var description: String
    lateinit var condition: String
    lateinit var category: String
    var imageUrl: String? = null
    lateinit var itemType: String
    var pricePerDay: BigDecimal = BigDecimal.ZERO
    lateinit var availableFrom: LocalDateTime
    lateinit var availableTo: LocalDateTime
    lateinit var status: String
    var createdAt: LocalDateTime = LocalDateTime.now()
    var updatedAt: LocalDateTime = LocalDateTime.now()

    // No-args constructor (Required for JPA)
    constructor()

    // All-args constructor
    constructor(
        itemId: Long?,
        user: User,
        title: String,
        description: String,
        condition: String,
        category: String,
        imageUrl: String?,
        itemType: String,
        pricePerDay: BigDecimal,
        availableFrom: LocalDateTime,
        availableTo: LocalDateTime,
        status: String,
        createdAt: LocalDateTime,
        updatedAt: LocalDateTime
    ) {
        this.itemId = itemId
        this.user = user
        this.title = title
        this.description = description
        this.condition = condition
        this.category = category
        this.imageUrl = imageUrl
        this.itemType = itemType
        this.pricePerDay = pricePerDay
        this.availableFrom = availableFrom
        this.availableTo = availableTo
        this.status = status
        this.createdAt = createdAt
        this.updatedAt = updatedAt
    }
}
package com.donateraja.entity.item

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "item_images")
class ItemImage(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val imageId: Long? = null,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "item_id", nullable = false)
    val item: Item,

    @Column(nullable = false)
    val imageUrl: String,

    @Column(nullable = false)
    val createdAt: LocalDateTime = LocalDateTime.now()
)
package com.donateraja.entity.item

import com.donateraja.entity.user.User
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "item_reviews")
class ItemReview(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val reviewId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "item_id")
    val item: Item,

    @ManyToOne
    @JoinColumn(name = "user_id")
    val user: User,

    val rating: Int,

    val comment: String,

    val createdAt: LocalDateTime
)
package com.donateraja.entity.item

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime
@Entity
@Table(name = "item_tags")
data class ItemTag(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val tagId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "item_id", nullable = false)
    val item: Item,

    @Column(nullable = false)
    val tag: String, //  Ensure this exists

    val createdAt: LocalDateTime
)
package com.donateraja.entity

import com.donateraja.entity.constants.RequestStatus
import com.donateraja.entity.constants.RequestType
import com.donateraja.entity.item.Item
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "item_requests")
class ItemRequest(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "request_id", nullable = false, updatable = false)
    val id: Long = 0,

    @Column(name = "user_id", nullable = false)
    val userId: Long,

    @ManyToOne
    @JoinColumn(name = "item_id", nullable = false)
    val item: Item,

    @Enumerated(EnumType.STRING)
    @Column(name = "request_type", nullable = false)
    val requestType: RequestType,

    @Column
    val message: String? = null,

    @Column(name = "rental_start_date")
    val rentalStartDate: LocalDateTime? = null,

    @Column(name = "rental_end_date")
    val rentalEndDate: LocalDateTime? = null,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var status: RequestStatus = RequestStatus.PENDING,

    @Column(name = "created_at", nullable = false)
    val createdAt: LocalDateTime = LocalDateTime.now(),

    @Column(name = "updated_at", nullable = false)
    var updatedAt: LocalDateTime = LocalDateTime.now()
)
package com.donateraja.entity

import com.donateraja.entity.user.User
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "messages")
data class Message(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val messageId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "sender_id")
    val sender: User,

    @ManyToOne
    @JoinColumn(name = "receiver_id")
    val receiver: User,

    val content: String,

    val createdAt: LocalDateTime
)
package com.donateraja.entity

import com.donateraja.entity.user.User
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "notifications")
data class Notification(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val notificationId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "user_id")
    val user: User,

    val message: String,

    val type: String,

    val status: String,

    val createdAt: LocalDateTime
)
package com.donateraja.entity

import com.donateraja.entity.item.Item
import com.donateraja.entity.user.User
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.math.BigDecimal
import java.time.LocalDateTime

@Entity
@Table(name = "payment_transactions")
data class PaymentTransaction(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val paymentId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "user_id")
    val user: User,

    @ManyToOne
    @JoinColumn(name = "item_id")
    val item: Item,

    val amount: BigDecimal,

    val transactionDate: LocalDateTime
)
package com.donateraja.entity

import com.donateraja.entity.item.Item
import com.donateraja.entity.user.User
import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.math.BigDecimal
import java.time.LocalDateTime

@Entity
@Table(name = "rental_transactions")
data class RentalTransaction(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val transactionId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "item_id")
    val item: Item,

    @ManyToOne
    @JoinColumn(name = "renter_id")
    val renter: User,

    val rentalPrice: BigDecimal,

    val rentalStartDate: LocalDateTime,

    val rentalEndDate: LocalDateTime,

    val status: String,

    val createdAt: LocalDateTime
)
package com.donateraja.entity
enum class ReportStatus {
    PENDING,
    REVIEWED,
    RESOLVED
}
package com.donateraja.entity.user

import com.fasterxml.jackson.annotation.JsonBackReference
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "addresses")
@JsonIgnoreProperties("user")
class Address(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "address_id")
    val id: Long = 0,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @JsonBackReference
    var user: User? = null, // Set nullable to allow default constructor

    @Column(nullable = false)
    var street: String = "",

    @Column(nullable = false)
    var city: String = "",

    @Column(nullable = false)
    var state: String = "",

    @Column(nullable = false)
    var pincode: String = "",

    var country: String? = null,

    val createdAt: LocalDateTime = LocalDateTime.now(),

    val updatedAt: LocalDateTime = LocalDateTime.now()
) {
    //  Default constructor required by JPA
    constructor() : this(
        id = 0,
        user = null, // Null user by default
        street = "",
        city = "",
        state = "",
        pincode = "",
        country = null,
        createdAt = LocalDateTime.now(),
        updatedAt = LocalDateTime.now()
    )
}
package com.donateraja.entity.user

import com.donateraja.entity.constants.Gender
import com.donateraja.entity.constants.UserStatus
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import com.fasterxml.jackson.annotation.JsonManagedReference
import jakarta.persistence.CascadeType
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.OneToMany
import jakarta.persistence.Table
import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotNull
import jakarta.validation.constraints.Size
import org.springframework.security.core.GrantedAuthority
import org.springframework.security.core.userdetails.UserDetails
import java.time.LocalDate
import java.time.LocalDateTime

@Entity
@Table(name = "users")
@JsonIgnoreProperties("addresses", "roles")
class User(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id", nullable = false, updatable = false)
    val id: Long = 0,

    @Column(unique = true, nullable = false)
    @Email(message = "Email should be valid")
    @NotNull(message = "Email cannot be null")
    var email: String = "",

    @Column(name = "phone_number", unique = true)
    var phoneNumber: String? = null,

    @Column(nullable = false)
    @Size(min = 8, message = "Password must be at least 8 characters long")
    @NotNull(message = "Password cannot be null")
    private var password: String, // Made private for security

    @Column(unique = true, nullable = false)
    @Size(min = 3, message = "Username must be at least 3 characters long")
    @NotNull(message = "Username cannot be null")
    private var username: String,

    @Column(name = "first_name")
    var firstName: String? = null,

    @Column(name = "last_name")
    var lastName: String? = null,

    @Column(name = "profile_picture")
    var profilePicture: String? = null,

    @Column(name = "user_bio")
    var userBio: String? = null,

    @Enumerated(EnumType.STRING)
    @Column(name = "gender", nullable = false)
    var gender: Gender = Gender.PREFER_NOT_TO_SAY,

    @Column(name = "dob")
    var dob: LocalDate? = null,

    @Column(nullable = false)
    @Enumerated(EnumType.STRING)
    var userStatus: UserStatus = UserStatus.ACTIVE,

    @Column(name = "is_email_verified")
    var isEmailVerified: Boolean = false,

    @Column(name = "is_phone_verified")
    var isPhoneVerified: Boolean = false,

    @Column(name = "verification_code")
    var verificationCode: String? = null,

    @Column(name = "verification_expires")
    var verificationExpires: LocalDateTime? = null,

    @Column(name = "created_at", updatable = false)
    var createdAt: LocalDateTime = LocalDateTime.now(),

    @Column(name = "updated_at")
    var updatedAt: LocalDateTime = LocalDateTime.now(),

    @Column(name = "last_login_at")
    var lastLoginAt: LocalDateTime? = null,

    @OneToMany(mappedBy = "user", fetch = FetchType.EAGER, cascade = [CascadeType.ALL], orphanRemoval = true)
    @JsonManagedReference
    val addresses: MutableSet<Address> = mutableSetOf(),

    @OneToMany(mappedBy = "user", fetch = FetchType.EAGER, cascade = [CascadeType.ALL], orphanRemoval = true)
    @JsonManagedReference
    val roles: MutableSet<UserRole> = mutableSetOf()
) : UserDetails {

    override fun getAuthorities(): MutableCollection<out GrantedAuthority> =
        roles.map { GrantedAuthority { it.role.name } }.toMutableList()

    override fun getPassword(): String = password // Expose for Spring Security authentication

    override fun getUsername(): String = email // Spring Security uses email for authentication

    override fun isAccountNonExpired(): Boolean = true

    override fun isAccountNonLocked(): Boolean = userStatus == UserStatus.ACTIVE

    override fun isCredentialsNonExpired(): Boolean = true

    override fun isEnabled(): Boolean = userStatus == UserStatus.ACTIVE

    fun updatePassword(newPassword: String) {
        this.password = newPassword
    }

    // Prevent infinite recursion in equals/hashCode
    override fun equals(other: Any?): Boolean {
        if (this === other) return true
        if (other !is User) return false
        return id == other.id
    }

    override fun hashCode(): Int = id.hashCode()
    constructor() : this(
        0, "", "", "", "",
        null, null, null, "",
        Gender.PREFER_NOT_TO_SAY, LocalDate.now(), UserStatus.ACTIVE,
        false, false, null,
        null, LocalDateTime.now(), LocalDateTime.now(), null
    )
}
package com.donateraja.entity.user

import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.OneToOne
import jakarta.persistence.Table

@Entity
@Table(name = "user_preferences")
data class UserPreference(
    @Id
    @OneToOne
    @JoinColumn(name = "user_id")
    val user: User,

    val receiveNotifications: Boolean,

    val showProfilePublicly: Boolean,

    val preferredLanguage: String
)
package com.donateraja.entity.user

import jakarta.persistence.Entity
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table
import java.time.LocalDateTime

@Entity
@Table(name = "user_reports")
data class UserReport(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val reportId: Long? = null,

    @ManyToOne
    @JoinColumn(name = "reported_user_id")
    val reportedUser: User,

    @ManyToOne
    @JoinColumn(name = "reported_by_user_id")
    val reportedByUser: User,

    val reason: String,

    val status: String,

    val createdAt: LocalDateTime
)
package com.donateraja.entity.user

import com.donateraja.entity.constants.Role
import com.fasterxml.jackson.annotation.JsonBackReference
import com.fasterxml.jackson.annotation.JsonIgnoreProperties
import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import jakarta.persistence.FetchType
import jakarta.persistence.GeneratedValue
import jakarta.persistence.GenerationType
import jakarta.persistence.Id
import jakarta.persistence.JoinColumn
import jakarta.persistence.ManyToOne
import jakarta.persistence.Table

@Entity
@Table(name = "user_roles")
@JsonIgnoreProperties("user")
class UserRole(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "role_id", nullable = false, updatable = false)
    val id: Long = 0,

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "user_id", nullable = false)
    @JsonBackReference
    var user: User,

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    var role: Role
) {
    constructor() : this(0, User(), Role.USER) //  Default constructor for Hibernate
}
package com.donateraja.entity.user

import com.donateraja.entity.constants.Role
import jakarta.persistence.Column
import jakarta.persistence.EnumType
import jakarta.persistence.Enumerated
import java.io.Serializable

// @Embeddable
class UserRoleId(
    @Column(name = "user_id")
    var userId: Long = 0,

    @Enumerated(EnumType.STRING)
    @Column(name = "role")
    var role: Role = Role.USER
) : Serializable {
    constructor() : this(0, Role.USER)
}
import com.fasterxml.jackson.annotation.JsonProperty
import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class AddressDto(
    @JsonProperty("pin_code")
    @NotBlank(message = "Pin code is required")
    @Size(max = 20, message = "Pin code must not exceed 20 characters")
    val pinCode: String,

    @JsonProperty("street")
    @NotBlank(message = "Street is required")
    val street: String? = null,

    @JsonProperty("city")
    @NotBlank(message = "City is required")
    val city: String? = null,

    @JsonProperty("state")
    @NotBlank(message = "State is required")
    val state: String? = null
)
package com.donateraja.model.user

import jakarta.validation.constraints.NotBlank
import jakarta.validation.constraints.Size

data class ChangePasswordDto(
    @NotBlank(message = "Current password is required")
    val currentPassword: String,

    @NotBlank(message = "New password is required")
    @Size(min = 8, message = "New password must be at least 8 characters long")
    val newPassword: String
)
package com.donateraja.model.user

import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class ResetPasswordDto(
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    val email: String
)
package com.donateraja.model.user

import jakarta.validation.constraints.Email
import jakarta.validation.constraints.NotBlank

data class UserLoginDto(
    @NotBlank(message = "Email is required")
    @Email(message = "Invalid email format")
    val email: String,

    @NotBlank(message = "Password is required")
    val password: String
)
package com.donateraja.model.user

import com.donateraja.domain.user.AddressResponseDTO
import com.donateraja.entity.constants.Gender
import com.fasterxml.jackson.annotation.JsonFormat
import java.time.LocalDate

data class UserProfileDto(
    val firstName: String,
    val lastName: String,
    val phoneNumber: String?,
    val profilePicture: String?,
    val userBio: String,
    val gender: Gender,

    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd")
    val dob: LocalDate?,
    val address: AddressResponseDTO?
)
package com.donateraja.model.user

import com.fasterxml.jackson.annotation.JsonProperty

data class UserRegistrationResponse(
    @JsonProperty("message")
    val message: String,

    @JsonProperty("user_id")
    val userId: Long
)
package com.donateraja.repository

import com.donateraja.entity.user.Address
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

@Repository
interface AddressRepository : JpaRepository<Address, Long> {
    fun findByUserId(userId: Long): Address
}
package com.donateraja.repository

import com.donateraja.entity.Category
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

@Repository
interface CategoryRepository : JpaRepository<Category, Long> {
    fun findByName(name: String): Category?
}
package com.donateraja.repository

import com.donateraja.entity.Condition
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

@Repository
interface ConditionRepository : JpaRepository<Condition, Long>
package com.donateraja.repository

import com.donateraja.entity.item.ItemImage
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

@Repository
interface ItemImageRepository : JpaRepository<ItemImage, Long> {
    fun findByItemId(itemId: Long): List<ItemImage>

    // ItemImageRepository.kt
    fun deleteByItemId(itemId: Long)
}
package com.donateraja.repository

import com.donateraja.entity.constants.Category
import com.donateraja.entity.constants.DonationOrRent
import com.donateraja.entity.item.Item
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository

@Repository
interface ItemRepository : JpaRepository<Item, Long> {

    @Query(
        """
        SELECT i FROM Item i 
        WHERE i.pincode = :pincode 
        AND (:category IS NULL OR i.category = :category) 
        AND (:donationOrRent IS NULL OR i.donationOrRent = :donationOrRent)
    """
    )
    fun findByPincodeAndFilters(
        @Param("pincode") pincode: String,
        @Param("category") category: Category?,
        @Param("donationOrRent") donationOrRent: DonationOrRent?
    ): List<Item>

    @Query(
        """
        SELECT i FROM Item i 
        WHERE (:category IS NULL OR i.category = :category) 
        AND (:donationOrRent IS NULL OR i.donationOrRent = :donationOrRent) 
        AND (:location IS NULL OR i.location ILIKE CONCAT('%', :location, '%'))
    """
    )
    fun findAllByFilters(
        @Param("category") category: Category?,
        @Param("donationOrRent") donationOrRent: DonationOrRent?,
        @Param("location") location: String?
    ): List<Item>

    @Query(
        """
        SELECT i FROM Item i 
        WHERE (:category IS NULL OR i.category = :category) 
        AND (:donationOrRent IS NULL OR i.donationOrRent = :donationOrRent) 
        AND (
            i.itemName ILIKE :query 
            OR i.description ILIKE :query
        )
    """
    )
    fun searchByQuery(
        @Param("query") query: String,
        @Param("category") category: Category?,
        @Param("donationOrRent") donationOrRent: DonationOrRent?
    ): List<Item>
}
package com.donateraja.repository

import com.donateraja.entity.ItemRequest
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

@Repository
interface ItemRequestRepository : JpaRepository<ItemRequest, Long> {
    fun findByUserId(userId: Long): List<ItemRequest>
    fun findByItemId(itemId: Long): List<ItemRequest>
    fun findByItem_UserId(userId: Long): List<ItemRequest>
}
package com.donateraja.repository

import com.donateraja.entity.item.ItemTag
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.stereotype.Repository

@Repository
interface TagRepository : JpaRepository<ItemTag, Long> {
    fun deleteByItemId(itemId: Long)
    fun findByItemId(itemId: Long): List<ItemTag>
    fun findByTag(tag: String): ItemTag?
}
package com.donateraja.repository

import com.donateraja.entity.user.User
import org.springframework.data.jpa.repository.JpaRepository
import org.springframework.data.jpa.repository.Query
import org.springframework.data.repository.query.Param
import org.springframework.stereotype.Repository

@Repository
interface UserRepository : JpaRepository<User, Long> {
    fun findByEmail(email: String): User?

//    fun findByEmail(email: String): Optional<User>
    fun findByPhoneNumber(phoneNumber: String): User?

    fun existsByEmail(email: String): Boolean

    @Query("SELECT u FROM User u WHERE u.email = :input OR u.phoneNumber = :input OR u.id = :input")
    fun findByAnyIdentifier(@Param("input") input: String): User?
}
package com.donateraja.repository

import com.donateraja.entity.constants.Role
import com.donateraja.entity.user.User
import com.donateraja.entity.user.UserRole
import org.springframework.data.jpa.repository.JpaRepository

interface UserRolesRepository : JpaRepository<UserRole, Long> {
    fun existsByUserAndRole(user: User, role: Role): Boolean
}
package com.donateraja.service

import com.donateraja.domain.auth.AuthRequest
import com.donateraja.domain.auth.AuthResponse
import com.donateraja.domain.user.UserRegistrationRequest

interface AuthService {
    fun registerUser(userRegistrationRequest: UserRegistrationRequest): AuthResponse
    fun loginUser(request: AuthRequest): AuthResponse
    fun refreshToken(refreshToken: String): AuthResponse
    fun logoutUser(token: String): String
    fun verifyEmail(token: String)
    fun resendVerificationEmail(email: String)
}
package com.donateraja.service

import org.springframework.web.multipart.MultipartFile

interface ImageService {
    fun uploadImages(files: List<MultipartFile>, uploadType: String): List<String>
    fun uploadProfilePicture(file: MultipartFile): String
    fun uploadImages(files: List<MultipartFile>): List<String>
}
package com.donateraja.service.impl

import com.donateraja.common.exception.ServiceException
import com.donateraja.common.util.JwtUtil
import com.donateraja.domain.auth.AuthRequest
import com.donateraja.domain.auth.AuthResponse
import com.donateraja.domain.user.UserRegistrationRequest
import com.donateraja.entity.constants.Role
import com.donateraja.entity.user.Address
import com.donateraja.entity.user.User
import com.donateraja.entity.user.UserRole
import com.donateraja.repository.AddressRepository
import com.donateraja.repository.UserRepository
import com.donateraja.service.AuthService
import org.slf4j.MDC
import org.springframework.http.HttpStatus
import org.springframework.security.authentication.AuthenticationManager
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class AuthServiceImpl(
    private val userRepository: UserRepository,
    private val addressRepository: AddressRepository,
    private val jwtUtil: JwtUtil,
    private val authenticationManager: AuthenticationManager
) : AuthService {
    private val passwordEncoder = BCryptPasswordEncoder()

    @Transactional
    override fun registerUser(userRegistrationRequest: UserRegistrationRequest): AuthResponse {
        if (userRepository.existsByEmail(userRegistrationRequest.email!!)) {
            throw ServiceException(HttpStatus.CONFLICT, "User with email ${userRegistrationRequest.email} already exists")
        }

        return try {
            val user = User(
                email = userRegistrationRequest.email!!,
                password = passwordEncoder.encode(userRegistrationRequest.password),
                username = userRegistrationRequest.username!!,
                firstName = userRegistrationRequest.firstName,
                lastName = userRegistrationRequest.lastName,
                phoneNumber = userRegistrationRequest.phoneNumber
            )

            //  Add role before saving
            user.roles.add(UserRole(user = user, role = Role.USER)) // Ensure this method exists in your User entity

            //  Add address before saving (if provided)
            if (!userRegistrationRequest.pincode.isNullOrEmpty()) {
                val address = Address(user = user, pincode = userRegistrationRequest.pincode!!)
                user.addresses.add(address) // Assuming User has List<Address>
            }

            val savedUser = userRepository.save(user) //  Save everything in one go

            val authentication = UsernamePasswordAuthenticationToken(user.email, user.password)
            val authResponse = jwtUtil.generateAccessToken(authentication)
            authResponse
        } catch (e: Exception) {
            throw ServiceException(HttpStatus.INTERNAL_SERVER_ERROR, "User registration failed: ${e.message}")
        }
    }

    @Throws(ServiceException::class)
    override fun refreshToken(refreshToken: String): AuthResponse = try {
        val userId = MDC.get("user_id")
//        val user = userRepository.findByEmail(userId)
        if (!userRepository.existsByEmail(userId)) {
            throw ServiceException(HttpStatus.CONFLICT, "User with refresh token failed. user not exist")
        }
        val user = userRepository.findByEmail(userId)
        val authentication = UsernamePasswordAuthenticationToken(user!!.email, user!!.password)
        val authResponse = jwtUtil.generateAccessToken(authentication)
        authResponse
    } catch (e: Exception) {
        throw ServiceException(HttpStatus.INTERNAL_SERVER_ERROR, "User registration failed: ${e.message}")
    }

    override fun loginUser(authRequest: AuthRequest): AuthResponse {
        val identifier = authRequest.identifier!!
        val password = authRequest.password!!
        val user: User? = when {
            identifier.contains("@") -> userRepository.findByEmail(identifier)
            identifier.all { it.isDigit() } -> {
                userRepository.findByPhoneNumber(identifier)
                    ?: identifier.toLongOrNull()?.let { userRepository.findById(it).orElse(null) }
            }
            else -> throw ServiceException(HttpStatus.UNAUTHORIZED, "UserId or Email or Phone is invalid")
        }
        if (user == null) {
            throw ServiceException(HttpStatus.UNAUTHORIZED, "UserId or Email or Phone is invalid")
        }
        val authentication = authenticationManager.authenticate(
            UsernamePasswordAuthenticationToken(identifier, password)
        )
        return jwtUtil.generateAccessToken(authentication)
    }

    override fun logoutUser(token: String): String {
        if (!jwtUtil.validateToken(token)) {
            throw ServiceException(HttpStatus.UNAUTHORIZED, "Invalid or expired token")
        }
        val rawToken = token.replace("Bearer ", "")
        jwtUtil.addToBlacklist(rawToken) // Actual invalidation
        return "Success"
    }

    override fun resendVerificationEmail(email: String) {
        TODO("Not yet implemented")
    }

    override fun verifyEmail(token: String) {
        TODO("Not yet implemented")
    }
}
package com.donateraja.service.impl

import com.backblaze.b2.client.contentSources.B2ContentTypes
import com.donateraja.common.BackblazeUtil
import com.donateraja.common.exception.ServiceException
import com.donateraja.common.util.ImageValidator
import com.donateraja.service.ImageService
import org.slf4j.MDC
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Service
import org.springframework.web.multipart.MultipartFile
import java.util.UUID

@Service
class ImageServiceImpl(private val backblazeUtil: BackblazeUtil, private val imageValidator: ImageValidator) : ImageService {

    override fun uploadImages(files: List<MultipartFile>, uploadType: String): List<String> {
        val userId = getUserIdFromContext()
        return files.mapIndexed { index, file ->
            // Use mapIndexed for index
            imageValidator.validateImageFile(
                file = file,
                uploadType = uploadType,
                index = index
            )
            backblazeUtil.uploadFile(
                fileBytes = file.bytes,
                fileName = "users/$userId/${UUID.randomUUID()}.${file.extension}",
                contentType = file.contentType ?: B2ContentTypes.B2_AUTO
            )
        }
    }

    override fun uploadImages(files: List<MultipartFile>): List<String> {
        val userId = getUserIdFromContext()
        return files.mapIndexed { index, file ->
            // Use mapIndexed for index
            imageValidator.validateImageFile(
                file = file,
                uploadType = "items", // Default upload type
                index = index
            )
            backblazeUtil.uploadFile(
                fileBytes = file.bytes,
                fileName = "users/$userId/${UUID.randomUUID()}.${file.extension}",
                contentType = file.contentType ?: B2ContentTypes.B2_AUTO
            )
        }
    }

    override fun uploadProfilePicture(file: MultipartFile): String {
        val userId = getUserIdFromContext()
        imageValidator.validateImageFile(
            file = file,
            uploadType = "profile", // Explicit upload type
            index = null // No index for single file
        )
        return backblazeUtil.uploadFile(
            fileBytes = file.bytes,
            fileName = "users/$userId/profile/${UUID.randomUUID()}.${file.extension}",
            contentType = file.contentType ?: "image/jpeg"
        )
    }

    private fun getUserIdFromContext(): String = MDC.get("user_id")
        ?: throw ServiceException(HttpStatus.UNAUTHORIZED, "User context not found")

    private val MultipartFile.extension: String
        get() = originalFilename?.substringAfterLast('.', "")
            ?: throw ServiceException(HttpStatus.BAD_REQUEST, "Invalid file extension")
}
package com.donateraja.service.impl

import com.donateraja.domain.request.ItemRequestCreateDTO
import com.donateraja.domain.request.ItemRequestResponseDTO
import com.donateraja.domain.request.ItemRequestStatusDTO
import com.donateraja.entity.ItemRequest
import com.donateraja.entity.constants.RequestStatus
import com.donateraja.repository.ItemRepository
import com.donateraja.repository.ItemRequestRepository
import com.donateraja.repository.UserRepository
import com.donateraja.service.ItemRequestService
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Service
import org.springframework.web.server.ResponseStatusException

@Service
class ItemRequestServiceImpl(
    private val itemRequestRepository: ItemRequestRepository,
    private val itemRepository: ItemRepository,
    private val userRepository: UserRepository
) : ItemRequestService {

    override fun createRequest(requestCreateDTO: ItemRequestCreateDTO): ItemRequestResponseDTO {
        val user = userRepository.findById(requestCreateDTO.userId!!)
            .orElseThrow { ResponseStatusException(HttpStatus.NOT_FOUND, "User not found") }
        val item = itemRepository.findById(requestCreateDTO.itemId!!)
            .orElseThrow { ResponseStatusException(HttpStatus.NOT_FOUND, "Item not found") }

        val request = ItemRequest(
            userId = user.id,
            item = item,
            requestType = requestCreateDTO.requestType!!,
            message = requestCreateDTO.message,
            rentalStartDate = requestCreateDTO.rentalStartDate,
            rentalEndDate = requestCreateDTO.rentalEndDate,
            status = RequestStatus.PENDING
        )
        itemRequestRepository.save(request)
        return mapToDTO(request)
    }

    override fun getRequestById(requestId: Long): ItemRequestResponseDTO {
        val request = itemRequestRepository.findById(requestId)
            .orElseThrow { ResponseStatusException(HttpStatus.NOT_FOUND, "Request not found") }
        return mapToDTO(request)
    }

    override fun updateRequestStatus(requestId: Long, requestStatusDTO: ItemRequestStatusDTO): ItemRequestResponseDTO {
        val request = itemRequestRepository.findById(requestId)
            .orElseThrow { ResponseStatusException(HttpStatus.NOT_FOUND, "Request not found") }
        request.status = requestStatusDTO.status!!
        itemRequestRepository.save(request)
        return mapToDTO(request)
    }

    override fun getSentRequests(userId: Long): List<ItemRequestResponseDTO> = itemRequestRepository.findByUserId(userId).map {
        mapToDTO(it)
    }

    override fun getReceivedRequests(userId: Long): List<ItemRequestResponseDTO> =
        itemRequestRepository.findByItem_UserId(userId).map {
            mapToDTO(it)
        }

    private fun mapToDTO(request: ItemRequest): ItemRequestResponseDTO = ItemRequestResponseDTO(
        id = request.id,
        userId = request.userId,
        itemId = request.item.id,
        requestType = request.requestType,
        message = request.message ?: "",
        rentalStartDate = request.rentalStartDate,
        rentalEndDate = request.rentalEndDate,
        status = request.status,
        createdAt = request.createdAt,
        updatedAt = request.updatedAt
    )
}
package com.donateraja.service.impl

import com.donateraja.common.exception.ServiceException
import com.donateraja.domain.item.ItemCreateDTO
import com.donateraja.domain.item.ItemResponseDTO
import com.donateraja.domain.item.ItemStatusDTO
import com.donateraja.domain.item.ItemUpdateDTO
import com.donateraja.entity.constants.Category
import com.donateraja.entity.constants.DonationOrRent
import com.donateraja.entity.item.Item
import com.donateraja.entity.item.ItemImage
import com.donateraja.entity.item.ItemTag
import com.donateraja.entity.user.User
import com.donateraja.repository.ItemImageRepository
import com.donateraja.repository.ItemRepository
import com.donateraja.repository.TagRepository
import com.donateraja.repository.UserRepository
import com.donateraja.service.ItemService
import org.springframework.http.HttpStatus
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional
import java.time.LocalDateTime

@Service
@Transactional
class ItemServiceImpl(
    private val itemRepository: ItemRepository,
    private val userRepository: UserRepository,
    private val itemImageRepository: ItemImageRepository,
    private val tagRepository: TagRepository
) : ItemService {

    override fun postItem(itemCreateDTO: ItemCreateDTO): ItemResponseDTO {
        val user = getUserById(itemCreateDTO.userId)
        val item = createItemEntity(itemCreateDTO, user)
        val savedItem = itemRepository.save(item)

        saveItemImages(savedItem, itemCreateDTO.imageUrls)
        saveItemTags(savedItem, itemCreateDTO.tags)

        return mapToResponseDTO(savedItem)
    }

    override fun getItem(itemId: Long): ItemResponseDTO {
        val item = itemRepository.findById(itemId)
            .orElseThrow { ServiceException(HttpStatus.NOT_FOUND, "Item not found") }
        return mapToResponseDTO(item)
    }

    override fun updateItem(itemId: Long, itemUpdateDTO: ItemUpdateDTO): ItemResponseDTO {
        val item = getItemEntity(itemId)

        itemUpdateDTO.itemName?.let { item.itemName = it }
        itemUpdateDTO.description?.let { item.description = it }
        itemUpdateDTO.price?.let { item.price = it }
        item.updatedAt = LocalDateTime.now()

        val updatedItem = itemRepository.save(item)
        return mapToResponseDTO(updatedItem)
    }

    override fun deleteItem(itemId: Long) {
        if (!itemRepository.existsById(itemId)) {
            throw ServiceException(HttpStatus.NOT_FOUND, "Item not found")
        }
        itemImageRepository.deleteByItemId(itemId)
        tagRepository.deleteByItemId(itemId)
        itemRepository.deleteById(itemId)
    }

    override fun updateItemStatus(itemId: Long, itemStatusDTO: ItemStatusDTO): ItemResponseDTO {
        val item = getItemEntity(itemId)
        item.status = itemStatusDTO.status ?: throw ServiceException(HttpStatus.BAD_REQUEST, "Status is required")
        item.updatedAt = LocalDateTime.now()
        return mapToResponseDTO(itemRepository.save(item))
    }

    override fun searchItemsByPincode(
        pincode: String,
        category: Category?,
        donationOrRent: DonationOrRent?
    ): List<ItemResponseDTO> = itemRepository.findByPincodeAndFilters(pincode, category, donationOrRent)
        .map { mapToResponseDTO(it) }

    override fun getAllItems(category: Category?, donationOrRent: DonationOrRent?, location: String?): List<ItemResponseDTO> =
        itemRepository.findAllByFilters(category, donationOrRent, location)
            .map { mapToResponseDTO(it) }

    override fun searchItems(query: String, category: Category?, donationOrRent: DonationOrRent?): List<ItemResponseDTO> =
        itemRepository.searchByQuery("%$query%", category, donationOrRent)
            .map { mapToResponseDTO(it) }

    private fun getUserById(userId: Long?): User =
        userRepository.findById(userId ?: throw ServiceException(HttpStatus.BAD_REQUEST, "User ID required"))
            .orElseThrow { ServiceException(HttpStatus.NOT_FOUND, "User not found") }

    private fun createItemEntity(dto: ItemCreateDTO, user: User): Item = Item(
        itemName = requireNotNull(dto.itemName) { "Item name required" },
        description = requireNotNull(dto.description) { "Description required" },
        condition = requireNotNull(dto.condition) { "Condition required" },
        price = requireNotNull(dto.price) { "Price required" },
        location = requireNotNull(dto.location) { "Location required" },
        pincode = requireNotNull(dto.pincode) { "Pincode required" },
        category = requireNotNull(dto.category) { "Category required" },
        donationOrRent = requireNotNull(dto.donationOrRent) { "Donation/Rent type required" },
        user = user
    )

    private fun saveItemImages(item: Item, imageUrls: List<String>) {
        imageUrls.forEach { url ->
            itemImageRepository.save(ItemImage(item = item, imageUrl = url))
        }
    }

    private fun saveItemTags(item: Item, tags: List<String>) {
        tags.forEach { tagName ->
            val cleanedTag = tagName.trim()
            if (cleanedTag.isNotEmpty()) {
                tagRepository.save(
                    ItemTag(
                        item = item,
                        tag = cleanedTag,
                        createdAt = LocalDateTime.now() // Add createdAt
                    )
                )
            }
        }
    }

    private fun getItemEntity(itemId: Long): Item = itemRepository.findById(itemId)
        .orElseThrow { ServiceException(HttpStatus.NOT_FOUND, "Item not found") }

    private fun mapToResponseDTO(item: Item): ItemResponseDTO = ItemResponseDTO(
        id = item.id,
        itemName = item.itemName,
        description = item.description,
        condition = item.condition,
        price = item.price,
        location = item.location,
        pincode = item.pincode,
        category = item.category,
        donationOrRent = item.donationOrRent,
        status = item.status,
        createdAt = item.createdAt,
        updatedAt = item.updatedAt,
        imageUrls = itemImageRepository.findByItemId(item.id).map { it.imageUrl },
        tags = tagRepository.findByItemId(item.id).map { it.tag }
    )
}
package com.donateraja.service.impl

import com.donateraja.common.exception.ServiceException
import com.donateraja.domain.user.AddressResponseDTO
import com.donateraja.entity.user.Address
import com.donateraja.entity.user.User
import com.donateraja.model.user.ChangePasswordDto
import com.donateraja.model.user.UserProfileDto
import com.donateraja.model.user.UserRegistrationResponse
import com.donateraja.repository.AddressRepository
import com.donateraja.repository.UserRepository
import com.donateraja.service.UserService
import org.slf4j.LoggerFactory
import org.springframework.http.HttpStatus
import org.springframework.security.crypto.password.PasswordEncoder
import org.springframework.stereotype.Service
import org.springframework.web.multipart.MultipartFile
import java.util.UUID

@Service
class UserServiceImpl(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
    private val addressRepository: AddressRepository
) : UserService {

    private val logger = LoggerFactory.getLogger(UserServiceImpl::class.java)

    override fun getCurrentUserProfile(): UserProfileDto {
        val user = getCurrentUser()
        val address = addressRepository.findByUserId(user.id) //  Fetch address
        return mapToUserProfileDto(user, address)
    }

    override fun updateUserProfile(userUpdateDTO: UserProfileDto): UserProfileDto {
        val user = getCurrentUser()

        //  Update user details
        user.firstName = userUpdateDTO.firstName
        user.lastName = userUpdateDTO.lastName
        user.phoneNumber = userUpdateDTO.phoneNumber
        userRepository.save(user)

        //  Fetch updated address before mapping response
        val address = addressRepository.findByUserId(user.id)

        return mapToUserProfileDto(user, address)
    }

    override fun changePassword(changePasswordDto: ChangePasswordDto) {
        val user = getCurrentUser()
        if (!passwordEncoder.matches(changePasswordDto.currentPassword, user.password)) {
            throw ServiceException(HttpStatus.BAD_REQUEST, "Current password is incorrect")
        }
        user.updatePassword(passwordEncoder.encode(changePasswordDto.newPassword))
        userRepository.save(user)
    }

    override fun updateProfilePicture(file: MultipartFile): UserProfileDto {
        val user = getCurrentUser()
        user.profilePicture = "/uploads/${UUID.randomUUID()}_${file.originalFilename}"
        userRepository.save(user)

        //  Fetch updated address before returning profile
        val address = addressRepository.findByUserId(user.id)

        return mapToUserProfileDto(user, address)
    }

    override fun getUserProfile(userId: Long): UserProfileDto {
        val user = userRepository.findById(userId).orElseThrow {
            throw ServiceException(HttpStatus.NOT_FOUND, "User with ID $userId not found")
        }
        val address = addressRepository.findByUserId(user.id) //  Fetch address
        return mapToUserProfileDto(user, address)
    }

    override fun resendVerificationEmail(userId: Long): UserRegistrationResponse {
        val user = userRepository.findById(userId).orElseThrow {
            throw ServiceException(HttpStatus.NOT_FOUND, "User not found")
        }
        user.verificationCode = UUID.randomUUID().toString()
        userRepository.save(user)
        logger.info("Resent verification email to ${user.email}")
        return UserRegistrationResponse("Verification email sent", user.id)
    }

    private fun getCurrentUser(): User =
        userRepository.findByEmail("test@example.com") ?: throw ServiceException(HttpStatus.NOT_FOUND, "User not found")

    private fun mapToUserProfileDto(user: User, address: Address?) = UserProfileDto(
        firstName = user.firstName ?: "",
        lastName = user.lastName ?: "",
        phoneNumber = user.phoneNumber,
        profilePicture = user.profilePicture,
        userBio = user.userBio ?: "",
        gender = user.gender,
        dob = user.dob,
        address = address?.let {
            AddressResponseDTO(
                street = it.street,
                city = it.city,
                state = it.state,
                pincode = it.pincode,
                country = it.country ?: ""
            )
        }
    )
}
package com.donateraja.service

import com.donateraja.domain.request.ItemRequestCreateDTO
import com.donateraja.domain.request.ItemRequestResponseDTO
import com.donateraja.domain.request.ItemRequestStatusDTO

interface ItemRequestService {
    fun createRequest(requestCreateDTO: ItemRequestCreateDTO): ItemRequestResponseDTO
    fun getRequestById(requestId: Long): ItemRequestResponseDTO
    fun updateRequestStatus(requestId: Long, requestStatusDTO: ItemRequestStatusDTO): ItemRequestResponseDTO
    fun getSentRequests(userId: Long): List<ItemRequestResponseDTO>
    fun getReceivedRequests(userId: Long): List<ItemRequestResponseDTO>
}
package com.donateraja.service

import com.donateraja.domain.item.ItemCreateDTO
import com.donateraja.domain.item.ItemResponseDTO
import com.donateraja.domain.item.ItemStatusDTO
import com.donateraja.domain.item.ItemUpdateDTO
import com.donateraja.entity.constants.Category
import com.donateraja.entity.constants.DonationOrRent

interface ItemService {
    fun postItem(itemCreateDTO: ItemCreateDTO): ItemResponseDTO
    fun getItem(itemId: Long): ItemResponseDTO
    fun updateItem(itemId: Long, itemUpdateDTO: ItemUpdateDTO): ItemResponseDTO
    fun deleteItem(itemId: Long)
    fun updateItemStatus(itemId: Long, itemStatusDTO: ItemStatusDTO): ItemResponseDTO
    fun searchItemsByPincode(pincode: String, category: Category?, donationOrRent: DonationOrRent?): List<ItemResponseDTO>
    fun getAllItems(category: Category?, donationOrRent: DonationOrRent?, location: String?): List<ItemResponseDTO>
    fun searchItems(query: String, category: Category?, donationOrRent: DonationOrRent?): List<ItemResponseDTO>
}
package com.donateraja.service

import com.donateraja.model.user.ChangePasswordDto
import com.donateraja.model.user.UserProfileDto
import com.donateraja.model.user.UserRegistrationResponse
import org.springframework.web.multipart.MultipartFile

interface UserService {
    fun getCurrentUserProfile(): UserProfileDto
    fun updateUserProfile(userUpdateDTO: UserProfileDto): UserProfileDto
    fun changePassword(changePasswordDto: ChangePasswordDto)
    fun updateProfilePicture(file: MultipartFile): UserProfileDto
    fun getUserProfile(userId: Long): UserProfileDto
    fun resendVerificationEmail(userId: Long): UserRegistrationResponse
}
